{"text": "DFPS Command-Line Forensics the EZ Way: Results in Seconds at the Command Line. With the wealth of data stored on Windows computers it is often difficult to know where to start. If you encounter a sizable hard drive, it could be hours or even days before you're ready to start your investigation, never mind reporting the results. Using the EZ tools provides scriptable, scalable, and repeatable results with astonishing speed and accuracy. Go from one investigation a week to several per day.", "metadata": {"source": "SANS_Command_Line", "title": "DFPS Command-Line Overview", "category": "dfir", "platform": "windows"}}
{"text": "Common CLI Options & Switches. Short options (single letter) are prefixed with a single dash. Long options are prefixed with two dashes. -d Dir to process. -f File to process. -q Quiet mode. --dt Custom date/Time format. --mp Higher precision timestamps are displayed and will also be reflected in any exported data. --csv --json --html Data can be exported to several formats. You can request multiple formats at the same time. --debug Shows debug info during tool execution (more info). --trace Shows trace info during tool execution (most info) can be run with debug (--debug --trace). --sync Sync updates from GitHub for KAPE targets & module updates. For evtxecmd map updates. -vss Process Volume Shadow Copies - Supported in EvtxECmd, MFTECmd, PECmd, and RECmd.", "metadata": {"source": "SANS_Command_Line", "title": "Common CLI Options and Switches", "category": "dfir", "platform": "windows"}}
{"text": "AppCompatCacheParser - Shimcache Parser. Type of Artifact: Application Compatibility Cache allows for older applications to be run on newer versions of Windows. When an executable is found, Windows determines how best to run the program and stores that data. AppCompatCache can be used to determine what was run. Basic Usage: AppCompatCacheParser, use the -f switch and point that to the SYSTEM registry hive. AppCompatCacheParser.exe -f E:\\Windows\\System32\\config\\SYSTEM --csv G:\\AppCompatCache. Key Data Returned: The columns of most significance are typically the Path (the location and name of the executable), LastModifiedTimeUTC (the last written time of the executable) and Executed (whether the executable was run). The most common mistake made by forensicators is that they'll assume that the LastModifiedTimeUTC value refers to the execution of the file. Don't fall into this trap!", "metadata": {"source": "SANS_Command_Line", "title": "AppCompatCacheParser - Shimcache Parser", "category": "dfir", "platform": "windows"}}
{"text": "AppCompatCacheParser Pro Tips. Watch for changes at the start of the Path. Anything that shows SYSVOL ran from the host's OS volume. Other volumes will be recorded by their drive letter. As a file's last written time does not change when a file is moved, renamed or copied, it may be possible to track the same executable across a single or even multiple systems, as a new entry will be created in the AppCompatCache when the file is executed from a different location or with a different name. Example showing same executable (same LastModifiedTimeUTC) running from different paths: SYSVOL\\Windows\\System32\\spinlock.exe (10/23/2019 14:27:18), SYSVOL\\Users\\SRogers\\AppData\\Local\\Temp\\spinlock.exe (10/23/2019 14:27:18), SYSVOL\\Windows\\prune.exe (10/23/2019 14:27:18).", "metadata": {"source": "SANS_Command_Line", "title": "AppCompatCacheParser Pro Tips", "category": "dfir", "platform": "windows"}}
{"text": "RBCmd - Recycle Bin Artifact Parser. Type of Artifact: When a user deletes a file, it is sent to the Recycle Bin. During that process, it is renamed. For example, if cat.jpg was deleted, the deleted file would have a name such as $R7YQ28P.jpg. The $R prefix means that it contains the content (Resource) of the original file. In addition to the $R file, a new corresponding $I (Information) file is created in the Recycle Bin. The $I file contains the information about the original location of the file and the date and time of deletion. RBCmd takes this data and presents it in a human-readable format.", "metadata": {"source": "SANS_Command_Line", "title": "RBCmd - Recycle Bin Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "RBCmd Basic Usage. Single file: RBCmd.exe -f E:\\$Recycle.Bin\\S-1-5-21-718126207-1171771683-1750804747-1001\\$I7YQ28P.jpg. Directory parsing: RBCmd.exe -d F:\\$Recycle.Bin\\S-1-5-21-718126207-1171771683-1750804747-1001 --csv G:\\RBFiles -q. Key Data Returned: Processed Recycle Bin data is either output to the screen (if no output file is specified). The source file is shown, as is the file size, original file name and location and date of deletion. Example output: Source file: .\\$IG1VEXX.xls, Version: 1 (Pre-Windows 10), File size: 16384 (16KB), File name: C:\\Users\\Donald\\SkyDrive\\Documents\\WACC Calc Spreadsheet -SECRET.xls, Deleted on: 2013-10-21 18:32:52.5320000", "metadata": {"source": "SANS_Command_Line", "title": "RBCmd Basic Usage and Output", "category": "dfir", "platform": "windows"}}
{"text": "RBCmd Pro Tip. Running RBCmd on a mounted drive will work, but remember that when doing so, Windows does not see deleted files, so RBCmd won't pick them up. It is often worth extracting deleted $I files using another tool and then running RBCmd over those recovered files.", "metadata": {"source": "SANS_Command_Line", "title": "RBCmd Pro Tip", "category": "dfir", "platform": "windows"}}
{"text": "bstrings - Extract Text From Binary Files. Type of Artifact: Bstrings can be used to search any type of file for potentially valuable information. Basic Usage: bstrings.exe -f <file>. Use --ls to search for string: bstrings -f suspect.exe --ls password. Use --lr to search with regular expression: bstrings -f suspect.exe --ls (ntos|win32k). Use --p to list builtin regular expressions: bstrings -p. Use --lr XX where XX represents a builtin regex: bstrings -f suspect.exe --lr ipv4. Use --fr to read file containing regex's to use in search: bstrings -f suspect.exe -fr DFIR_RegExs.txt. Use -h to list all options: bstrings -h. Use --cp to use a different ANSI code page: bstrings -f Powershell.evtx --ls download --cp 1201.", "metadata": {"source": "SANS_Command_Line", "title": "bstrings - Binary String Extraction", "category": "dfir", "platform": "windows"}}
{"text": "bstrings Advanced Usage. -p shows a list of built-in regular expressions. When using a built-in expression, use the value in the Name column. For example, to look for email addresses, use this command: bstrings.exe -f <some file> --lr email. Note: Windows Event Log require the 1201 specific code page for bstrings to find the search string. --lr Regular Expression searches bstrings and also contains over a dozen built-in regular expression patterns for things like credit card numbers, social security numbers, IP addresses, email addresses, and more. Use --off to show the offset for each search hit. Use the -x and -m switches to set maximum and minimum string lengths. bstrings also allows searching for several strings or regular expressions at once using the --fr and --fs switches. In addition to Unicode strings, bstrings looks for strings encoded using Western (1252) code page. Use the --cp switch to search in any other code page supported by .net. A full listing of available code pages is available at https://goo.gl/ig6DxW", "metadata": {"source": "SANS_Command_Line", "title": "bstrings Advanced Usage and Code Pages", "category": "dfir", "platform": "windows"}}
{"text": "SRUMECmd - SRUM Parser. Type of Artifact: SRUM (System Resource Usage Manager) records application usage, network usage, power usage, etc. Investigation of this artifact can assist in determining what applications were used, while also providing context into the network connection (including names of wireless networks) that was in use at the time. SRUM can also determine how much data was uploaded and downloaded by the application and even whether a laptop was connected to power or running on battery at the time.", "metadata": {"source": "SANS_Command_Line", "title": "SRUMECmd - SRUM Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "SRUMECmd Basic Usage. SRUMECmd takes a SRUDB.dat database and the SOFTWARE registry hive as input. However, the SRUDB.dat file must first be repaired by copying the contents of the Windows\\System32\\sru and running the following two commands in the folder containing the copied files: esentutl.exe /r sru /i /o, esentutl.exe /p SRUDB.dat /o. Once the repair is complete, SRUMECmd can be run: SRUMECmd.exe -f G:\\sru_fixed\\SRUDB.dat -r E:\\Windows\\System32\\config\\SOFTWARE --csv G:\\SRUM_output. Key Data Returned: Several CSV files will be output from running the command. Each CSV represents a different aspect of SRUM, including application resource usage, energy usage, network usage, network connections, etc. Each table is named and formatted according to the data contained therein. Note that the results are provided in time segments of 30 to 60 minutes.", "metadata": {"source": "SANS_Command_Line", "title": "SRUMECmd Basic Usage and Repair", "category": "dfir", "platform": "windows"}}
{"text": "SRUMECmd Pro Tip. As SRUM is recorded in 30-to-60-minute segments, the data can be opened in Excel and a graph plotted to show specific bandwidth and/or application usage over time. The graph output can then be used in reports to provide a clear visual of activity.", "metadata": {"source": "SANS_Command_Line", "title": "SRUMECmd Pro Tip", "category": "dfir", "platform": "windows"}}
{"text": "JLECmd - JumpList Explorer Command Line Edition. Type of Artifact: Jumplists store critical information about files and folders that have been used in Windows. Among other things, Jumplists contain information about the application used to open target files and folders and store metadata specific to them. Those metadata contain details such as file name and location, dates and times, etc. JLECmd makes parsing this data simple and quick.", "metadata": {"source": "SANS_Command_Line", "title": "JLECmd - JumpList Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "JLECmd Basic Usage. JLECmd takes either a single Jumplist file or a directory of Jumplists as input. If parsing a single Jumplist, use the -f option. If parsing a directory of Jumplists, use the -d option. It is also suggested that the -q switch be used to avoid dumping all results to the screen (which can dramatically slow down JLECmd's execution time). Single Jumplist: JLECmd.exe -f E:\\Users\\Donald\\AppData\\Microsoft\\Windows\\Recent\\AutomaticDestinations\\ff103e2cc310d0d.automaticDestinations-ms --csv G:\\Jumplists -q. All automatic jumplists for a user: JLECmd.exe -d E:\\Users\\Donald\\AppData\\Microsoft\\Windows\\Recent\\AutomaticDestinations --csv G:\\Jumplists -q", "metadata": {"source": "SANS_Command_Line", "title": "JLECmd Basic Usage", "category": "dfir", "platform": "windows"}}
{"text": "JLECmd Key Data Returned. The JLECmd output contains two important categories of data, evidence of execution and evidence of file knowledge. Significant columns: AppIdDescription (Human readable name for AppID), DestListVersion (Used with MRU to determine most recently opened file in the Jump List), MRU (Used with DestListVersion to determine most recently opened file in the Jump List), Path (Location and name of file opened), TargetCreated (Creation Timestamp of file referenced in JL), TargetModified (Modification Timestamp of file referenced in JL).", "metadata": {"source": "SANS_Command_Line", "title": "JLECmd Key Data Columns", "category": "dfir", "platform": "windows"}}
{"text": "JLECmd Pro Tip. Watch for changes in the DriveType, VolumeSerialNumber and VolumeLabel columns as the data in these columns can indicate whether files have been opened from external devices. The change in these columns shows that a file was opened from the USB device named FILES. Additionally, the local path may show the same drive letter for multiple removable devices (e.g., F:\\) but you should also review the volume serial number and the volume label to determine if the drive letter is associated with the same or different devices. A mapping of app_ids to app name can be found at https://for500.com/appid.", "metadata": {"source": "SANS_Command_Line", "title": "JLECmd Pro Tip - External Devices", "category": "dfir", "platform": "windows"}}
{"text": "VSCMount - Volume Shadow Copy Mounter. Type of Artifact: Volume Shadow Copies are created periodically to capture the previous state of a system. This means that deleted and wiped files, or even older versions of a file or folder, can be recovered from volume shadow copies. VSCMount allows an investigator to mount each volume shadow copy. Basic Usage: Before running the VSCMount tool, an evidence file must itself be mounted as a physical drive. Once mounted, note the drive letter. Open an Administrator PowerShell window and run VSCMount. The --dl switch stands for drive letter. The --mp switch stands for map point. Example: .\\VSCMount.exe --dl E --mp C:\\VSCs. Key Data Returned: When run, VSCMount maps each shadow copy to a separate folder. Inside the map point, there are mapped volume shadow copies from the mounted drive. Each of these can be expanded and viewed as needed.", "metadata": {"source": "SANS_Command_Line", "title": "VSCMount - Volume Shadow Copy Mounter", "category": "dfir", "platform": "windows"}}
{"text": "VSCMount Pro Tip. Looking at the mapped Volume Shadow Copies, it isn't immediately clear as to when they were created. Adding the --ud switch to the command adds the creation date of each mapped Volume Shadow Copy: .\\VSCMount.exe --dl E --mp C:\\VSCs --ud", "metadata": {"source": "SANS_Command_Line", "title": "VSCMount Pro Tip", "category": "dfir", "platform": "windows"}}
{"text": "SQLECmd - SQLite Parser. Type of Artifact: SQLite databases are used to store data for many applications. On a Windows computer, the most common use of SQLite is web browser data such as history, cloud storage, chat applications, phone backups, etc. As each SQLite database is different, SQLECmd makes use of custom maps. These maps are created to parse specific items. For example, when parsing the Google Chrome History database, SQLECmd recognizes the database schema (layout) for application and uses the relevant map file to interpret the data specific to Google Chrome.", "metadata": {"source": "SANS_Command_Line", "title": "SQLECmd - SQLite Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "SQLECmd Basic Usage. To parse a single SQLite database, point SQLECmd at a single database file using the -f switch: SQLECmd.exe -f G:\\databases\\database.db --csv G:\\SQLECmd_output. To parse a folder of SQLite databases, point SQLECmd at the folder and use the -d switch: SQLECmd.exe -d G:\\databases\\ --csv G:\\SQLECmd_output. Key Data Returned: Depending on the database being analyzed, several CSV files may be output. In the example of Google Chrome, pointing SQLECmd to the history database will result in history, downloads, and keyword search files, each containing their respective results.", "metadata": {"source": "SANS_Command_Line", "title": "SQLECmd Basic Usage", "category": "dfir", "platform": "windows"}}
{"text": "SQLECmd Pro Tip. SQLECmd only parses a database if a map file exists for that schema. Due to the large number of SQLite-based applications, it is impossible to have maps for every eventuality. However, creating a custom map file is as simple as generating a SQL query and adding it to SQLECmd folder.", "metadata": {"source": "SANS_Command_Line", "title": "SQLECmd Pro Tip", "category": "dfir", "platform": "windows"}}
{"text": "SumECmd - User Access Log Parser. Type of Artifact: User Access Logs are found in Windows Server operating systems. These logs records user requests related to a server. For example, if a user connects to a server, the username and client IP address are recorded with associated date and time. This can help track a user's lateral movement through the environment.", "metadata": {"source": "SANS_Command_Line", "title": "SumECmd - User Access Log Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "SumECmd Basic Usage. SumECmd takes the contents of the C:\\Windows\\System32\\LogFiles\\SUM folder as input. However, the databases stored in this folder must first be repaired by copying the contents of the folder and running the following commands on the copied files: esentutl.exe /r svc /i /o, esentutl.exe /p Current.mdb, esentutl.exe /p SystemIdentity.mdb, esentutl.exe /p <GUID>.mdb. Note that <GUID>.mdb is not actually named this way, the GUID will be different on every server. Once the repair is complete, SumECmd can be run: SumECmd.exe -d G:\\sum_fixed\\ --csv G:\\sum_output. Key Data Returned: A series of files is output from running the command. Perhaps the most significant of the files is named ClientDetail. In this file we are provided with dates and times of when the activity occurred and Role Description (used to identify the service being accessed). In addition, the domain, username, and IP address of the incoming access is also recorded.", "metadata": {"source": "SANS_Command_Line", "title": "SumECmd Basic Usage and Database Repair", "category": "dfir", "platform": "windows"}}
{"text": "SumECmd Pro Tip. Looking for domains, users and IP addresses that are not part of the organization will help to detect anomalous behavior and gives clues about the attacker.", "metadata": {"source": "SANS_Command_Line", "title": "SumECmd Pro Tip", "category": "dfir", "platform": "windows"}}
{"text": "PECmd - Prefetch Parser. Type of Artifact: Prefetch provides evidence of execution. Prefetch files are created or updated in the C:\\Windows\\Prefetch folder when a program attempts to run. Prefetch files are not automatically deleted if the related program is deleted and therefore can be a source of historical information. Prefetch is limited to 128 files, meaning that older files may be overwritten when that limit is reached. The creation time of a prefetch file is typically done so 10 seconds after first run.", "metadata": {"source": "SANS_Command_Line", "title": "PECmd - Prefetch Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "PECmd Basic Usage. Process a single Prefetch files and send results to screen: PECmd.exe -f C:\\Windows\\Prefetch\\CMD.EXE-8E75B5BB.pf. Process a directory of Prefetch files and send results to a CSV file named prefetch.csv. The --csvf allows you to provide the name of the prefetch output csv: PECmd.exe -d C:\\Windows\\Prefetch\\ -q --csv G:\\Prefetch --csvf prefetch.csv. Process a directory of Prefetch files, including VSS, and send the results to a CSV file named prefetch.csv and higher precision timestamps: PECmd.exe -d C:\\Windows\\Prefetch\\ -q --csv G:\\Prefetch --csvf prefetch.csv --vss --mp", "metadata": {"source": "SANS_Command_Line", "title": "PECmd Basic Usage", "category": "dfir", "platform": "windows"}}
{"text": "PECmd Key Data Returned. PECmd, in csv mode, will output two CSV files, one of which is a timeline. The Timeline csv will have _Timeline in the file name. The main Prefetch output file will contain important information such as: Executable name and full path from which it was executed, Volume name and serial number from which the program ran, Run Count - the number of time that the program was run from that location, Timestamps (UTC) for the last eight executions, Volumes files and directories accessed during execution.", "metadata": {"source": "SANS_Command_Line", "title": "PECmd Key Data Columns", "category": "dfir", "platform": "windows"}}
{"text": "PECmd Advanced Usage. KEYWORDS: Using comma-separated list of keywords will cause any hits to be shown in red: PECmd.exe -d C:\\Windows\\Prefetch\\ -q --csv G:\\Prefetch --csvf prefetch.csv -k \"system32, downloads, fonts\". PECmd can extract and process Prefetch files from Volume Shadow Copies by using the --vss option. This will process Prefetch from ALL Volume Shadow Copies. The output files will be separated by individual VSS numbers: PECmd.exe -d C:\\Windows\\Prefetch\\ -q --csv G:\\Prefetch --csvf prefetch.csv --vss", "metadata": {"source": "SANS_Command_Line", "title": "PECmd Advanced Usage and VSS", "category": "dfir", "platform": "windows"}}
{"text": "AmcacheParser - Amcache Parser. Type of Artifact: Amcache is part of the Application Experience Service in Windows. As such, it stores information about what application was run and a hash value of the executable. Basic Usage: AmcacheParser takes the Amcache.hve registry hive as input: AmcacheParser.exe -f E:\\Windows\\AppCompat\\Programs\\Amcache.hve --csv G:\\Amcache. Key Data Returned: The columns of most significance are typically the FileIDLastWriteTimestamp (the first time the executable was run), SHA1 (the SHA-1 hash of the file being executed) and FullPath (the location and name of the executable ran). Other data of potential interest include the Volume ID (used to determine from which volume the executable was run), MFT Entry number and Sequence numbers (used to determine if the executable was run from an NTFS volume) and information about the internal metadata of the executable itself.", "metadata": {"source": "SANS_Command_Line", "title": "AmcacheParser - Amcache Parser", "category": "dfir", "platform": "windows"}}
{"text": "AmcacheParser Pro Tips. Watch for changes in the VolumeID, as these can be indicative of applications being run from external devices. Looking for something specific in the Amcache? You can use the switches -b (blacklist) or -w (whitelist). Blacklisting will include only those Amcache entries that match the SHA-1 hashes specified in the file, while whitelisting will exclude those Amcache entries that match the SHA-1 hashes. Example: AmcacheParser.exe -f E:\\Windows\\AppCompat\\Programs\\Amcache.hve -b G:\\Blacklist.txt --csv G:\\Amcache", "metadata": {"source": "SANS_Command_Line", "title": "AmcacheParser Pro Tips", "category": "dfir", "platform": "windows"}}
{"text": "MFTECmd - MFT Explorer. Type of Artifact: MFTECmd parses a number of different files from NTFS-formatted drives. At a high level, MFTECmd parses each of these internal NTFS System files. At a lower level, the application dives deep into NTFS and helps uncover much data of interest. $MFT: Index of each file and folder on volume - contains file name timestamps and other metadata. $Boot: Volume boot record - contains volume serial nbr, volume signature, nbr of sectors. $SDS: File ownership - contains a list of all the Security Descriptors on the volume. $J: USN Journal - Transaction log of all changes to a file (write, delete, rename, etc.) (file change journal). $Logfile: Transaction Log File - Used by NTFS to maintain the integrity of the filesystem in the event of a crash (metadata change journal).", "metadata": {"source": "SANS_Command_Line", "title": "MFTECmd - NTFS System Files Overview", "category": "dfir", "platform": "windows"}}
{"text": "MFTECmd Basic Usage. MFTECmd takes a $MFT, $J, $SDS, $Logfile or $Boot as input. These input files can be in the form of an exported copy of the file(s) or by referencing them from within a mounted image. Parse $MFT: MFTECmd.exe -f 'G:\\Exports\\$MFT' --csv G:\\MFT_Output. Parse $MFT from mounted image: MFTECmd.exe -f 'E:\\$MFT' --csv G:\\MFT_Output. Parse USN Journal: MFTECmd.exe -f 'E:\\$Extend\\$UsnJrnl:$J' --csv G:\\USN_Output. Parse $SDS: MFTECmd.exe -f 'E:\\$Secure:$SDS' --csv G:\\SDS_Output. Note the command line syntax for referencing the alternate data streams $UsnJrnl and $Secure.", "metadata": {"source": "SANS_Command_Line", "title": "MFTECmd Basic Usage", "category": "dfir", "platform": "windows"}}
{"text": "MFTECmd Key Data - File Copy Detection. The columns of most significance are highly dependent on the type of investigation and the reason for parsing the files in the first place. For example, the dates and times in the $MFT could provide an indication as to the copying of files from external devices. If the written/modification time precedes the creation time, there is a high degree of probability that the file was copied from another volume. Example: In each row the Last Modified time precedes the Created time. This is a clear indication that these files were copied from another volume.", "metadata": {"source": "SANS_Command_Line", "title": "MFTECmd File Copy Detection", "category": "dfir", "platform": "windows"}}
{"text": "MFTECmd Key Data - USN Journal ($J). The processed $J data can be used to determine the date and time that specific actions were taken on a file. These actions include (but are not limited to) creating a new file, making changes to a file, deleting a file, overwriting a file, and renaming a file. The $LogFile tracks changes to the information found in the MFT such as timestamps and other metadata. Example: Follow the flow of activity the files recorded in $J. The first entry is for the creation of a file named $IT74KUZ, then data is added to the file before it is closed. Immediately afterwards, the file sdelete64.exe is renamed to $RT74KUZ before also being closed. This all happens within the same hundredth of a second as sdelete64.exe being sent to the $Recycle.bin.", "metadata": {"source": "SANS_Command_Line", "title": "MFTECmd USN Journal Analysis", "category": "dfir", "platform": "windows"}}
{"text": "MFTECmd Key Data - $SDS File Ownership. The $SDS file allows us determine file ownership. For example, looking at the NTUSER.DAT entry we can see that the Security ID for this file is 8271. If we then go to the $SDS output and search for that same Security ID, we find that the NTUSER.DAT file is owned by the user with the Relative ID of 1001. If needed, we can take the SID and tied it to a username via the SAM Registry Hive.", "metadata": {"source": "SANS_Command_Line", "title": "MFTECmd File Ownership via $SDS", "category": "dfir", "platform": "windows"}}
{"text": "MFTECmd Pro Tip - Timestamp Manipulation Detection. It is important to remember that NTFS stores two sets of dates and times in each $MFT entry. These are known as the Standard Information Attributes (SIA) and the FILENAME attributes. This means that each file and folder will have timestamps in both groups. These dates and times behave differently and can indicate when a file was truly created, not just what Windows reports. Example: Both dates and times are the same for the first two entries, but the third entry shows a FILENAME creation date that is much later than the creation date stored in the SIA. This may be an indication of manipulation of the SIA timestamp for the syncmon.exe file and would warrant further investigation. Created0x10 3/18/2019 09:19, Created0x30 8/18/2019 01:12, Path C:\\Windows\\System32\\syncmon.exe.", "metadata": {"source": "SANS_Command_Line", "title": "MFTECmd Timestamp Manipulation Detection", "category": "dfir", "platform": "windows"}}
{"text": "MFTECmd Pro Tip - Volume Shadow Copies. When an evidence file is mounted as a drive MFTECmd can also dive into the volume shadow copies and retrieve previous versions of the $MFT, the $J and $SDS files. This can be done by virtue of the switches --vss and --dedupe as demonstrated in the command: MFTECmd.exe -f 'E:\\$Extend\\$UsnJrnl:$J' --csv G:\\MFT_Output --vss --dedupe. The --vss switch tells MFTECmd to search in the volume shadow copies and the --dedupe switch stops MFTECmd from reporting duplicate entries found in the volume shadow copies.", "metadata": {"source": "SANS_Command_Line", "title": "MFTECmd Volume Shadow Copy Analysis", "category": "dfir", "platform": "windows"}}
{"text": "EvtxECmd - Windows Event Log Parser. Type of Artifact: There are many Event Logs in the evtx folder, some aimed at system-wide events like Security.evtx, System.evtx and Application.evtx. Others may contain more specific events. All Event Logs are stored in the same format but the actual data elements collected varies. It is this variation of data elements that makes correlation of Event Logs a challenge. This is where EvtxECmd shines. All events are normalized across all event types and across all Event Logs file types! The EvtxECmd parser has custom maps and locked file support. EvtxECmd has a unique feature, Maps, that allows for consistent output. Event Log Location: Event Logs for Windows Vista or later are found in %systemroot%\\System32\\winevt\\logs", "metadata": {"source": "SANS_Command_Line", "title": "EvtxECmd - Event Log Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "EvtxECmd Basic Usage. Recursively parsing a directory of event logs is probably the most efficient way to use EvtxECmd. To parse a directory, copy Event Logs to a temporary directory and use the -d option. Additionally, use the --inc option to only include specific Event_IDs in the processing. Process all event logs: EvtxECmd.exe -d E:\\evtx\\logs --csv G:\\evtx\\out --csvf evtxecmd_out.csv. Process all event logs and only include event_id specified by the --inc option: EvtxECmd.exe -d E:\\evtx\\logs --csv G:\\evtx\\out --csvf evtxecmd_out.csv --inc 4624,4625,4634,4647,4672. Exclude specific event_id's by using the --exc option: EvtxECmd.exe -d E:\\evtx\\logs --csv G:\\evtx\\out --csvf evtxecmd_out.csv --exc 4656,4660,4663.", "metadata": {"source": "SANS_Command_Line", "title": "EvtxECmd Basic Usage", "category": "dfir", "platform": "windows"}}
{"text": "EvtxECmd Pro Tips. Process only the Event Logs and Event IDs that are relevant to your case. Parsing all events could end in millions of results. Using EvtxECmd's maps can help target specific artifacts. Events without maps are still processed, but output format will vary. The normalized Event Log output makes it possible to analyze many different types of Event Logs in a single view. Timeline Explorer is perfect for this analysis. Check out this PowerShell script that copies out the relevant Event Logs and processes only specific Event IDs (your list of relevant logs and Event IDs may vary): https://for500.com/evtx2process", "metadata": {"source": "SANS_Command_Line", "title": "EvtxECmd Pro Tips", "category": "dfir", "platform": "windows"}}
{"text": "SBECmd - Shellbags Explorer. Type of Artifact: Every time Windows Explorer interacts with a folder, an entry is created in the user's Shellbags. Folders also include other Explorer Like items like the Control Panel, zip files, ISOs, and mounted encrypted containers. The simple existence of a directory in Shellbags is evidence the specific user account once interacted with that folder. Shellbags may persist long after the original directories, files, and physical devices have since been removed. ShellBags are a set of Windows Registry keys located in NTUser.dat and USRClass.dat Registry hives (primarily USRClass.dat) that maintain viewing preferences of folders when using Windows Explorer. We used to say the Shellbags tracked folders that a user opened.", "metadata": {"source": "SANS_Command_Line", "title": "SBECmd - Shellbags Explorer Overview", "category": "dfir", "platform": "windows"}}
{"text": "SBECmd Basic Usage. SBECmd uses -d for a directory to recursively process user registry hives. There is no -f option for SBECmd. To process a single user's ShellBags data: SBECmd.exe -d E:\\Users\\nromanoff --csv G:\\temp\\sbe_out. To process all Users in the Users folder: SBECmd.exe -d E:\\Users --csv G:\\tmp\\sbe_out. Pro Tip: If you need to process several users ShellBags data, you might consider exporting their data first and then processing just folder containing the exported data. This is a performance decision. Recursively processing many user folders can be very slow.", "metadata": {"source": "SANS_Command_Line", "title": "SBECmd Basic Usage", "category": "dfir", "platform": "windows"}}
{"text": "SBECmd Key Data Returned. File system dates and times for target folders and first and last folder interaction times. The Bag Path, Slot, Node Slot, and MRU position for each entry are also shown. These can initially be confusing to decipher in table form. Using the GUI version of ShellBags Explorer to see the table view translated in a hierarchal tree format can be very useful. Timestamps Shown in SBECmd output: Because of the nature of how registry key timestamps have only a single last update value for each key, the hierarchal data in the BagMRU registry key can become stale. This means that there may be a value in the key but it could be outdated. Therefore if SBECmd is not positive that a date is current and accurate, that date will not be shown in the output. This why you will often see that an entry has a Last Interacted Timestamp and no First Interacted Timestamp. The First Interacted Timestamp is stale and can't be relied upon. You will also notice that SBECmd will only show Last Interacted Timestamps for MRU values.", "metadata": {"source": "SANS_Command_Line", "title": "SBECmd Key Data and Timestamp Behavior", "category": "dfir", "platform": "windows"}}
{"text": "SBECmd Pro Tip. SBECmd can pull data from a live system. This make for a great learning and testing feature. Pull some baseline Shellbags data, run a test like navigating into a folder, pull the data again and compare. See what your own activity does to the Shellbags data.", "metadata": {"source": "SANS_Command_Line", "title": "SBECmd Pro Tip - Live System", "category": "dfir", "platform": "windows"}}
{"text": "LECmd - LNK File Explorer. Type of Artifact: Shortcut files (*.lnk) are not entirely human-readable. Lnk files are most frequently created when a user opens a non-executable file by double-clicking. These shortcut files are stored under the user profile that opened the file and contain information relating to the opened target file. This includes information such as the target file dates and times, file name and path, the drive type, volume serial number, volume label and more. LECmd takes this data and presents it in a human-readable format.", "metadata": {"source": "SANS_Command_Line", "title": "LECmd - LNK File Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "LECmd Basic Usage. LECmd takes, as input, either a single lnk file or a folder containing several such files. Single file: LECmd.exe -f E:\\Users\\srogers\\AppData\\Microsoft\\Windows\\Recent\\Peggy.jpg.lnk. Directory of lnk files with CSV output: LECmd.exe -d E:\\Users\\srogers\\AppData\\Microsoft\\Windows\\Recent --csv G:\\LnkFiles -q", "metadata": {"source": "SANS_Command_Line", "title": "LECmd Basic Usage", "category": "dfir", "platform": "windows"}}
{"text": "LECmd Key Data Returned. Significant columns: AppIdDescription (Human readable name for AppID), DestListVersion (Used with MRU to determine most recently opened file in the Jump List), MRU (Used with DestListVersion to determine most recently opened file in the Jump List), Path (Multiple Path Columns: Location and name of source and target files), SourceCreate (Creation Timestamp of the LNK itself), SourceModified (Modification Timestamp of the LNK itself), TargetCreated (Creation Timestamp of target file the LNK points to), TargetModified (Modification Timestamp of target file the LNK points to), DriveType (Network, fixed local, or Removable), VolumeSerialNumber, MFT Entry Number (MFT Nbr & Seq nbr - If present then Volume is NTFS).", "metadata": {"source": "SANS_Command_Line", "title": "LECmd Key Data Columns", "category": "dfir", "platform": "windows"}}
{"text": "LECmd Pro Tips - Timestamp Analysis. Taking the data from key columns not only tells a forensic investigator when the file was opened, but may also provide details about the number of times a user accessed a file with that name. Example 1: If SourceCreated and SourceModified contain the same time, the file was only opened once. Example 2: If SourceCreated occurred before SourceModified, the file has been opened at least twice. If Target dates are identical, the file has not been changed since it was created. Example 3: If SourceCreated and SourceModified are identical but TargetModified precedes TargetCreated, the file was only opened once but has been copied from another location. LNK facts to keep in mind: The target file name extension is not always provided in the LNK name. The LNK file points to the last file of that name. Meaning, if there were two files named exactly the same, the link files point to the last one opened.", "metadata": {"source": "SANS_Command_Line", "title": "LECmd Pro Tips - Timestamp Analysis", "category": "dfir", "platform": "windows"}}
{"text": "RECmd - Registry Explorer Command Line Edition. Type of Artifact: This command line tool is used to access, search and recover, and export any data found in the Windows Registry. To grasp why this tool is so powerful, just think about searching and exporting registry in a consistent output format. It's no big deal to do this with other tools until you have to do exactly the same thing across tens, hundreds, or thousands of machines. RECmd will replay and apply all registry hive logs automatically. Use --nl to suppress this.", "metadata": {"source": "SANS_Command_Line", "title": "RECmd - Registry Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "RECmd Basic Usage. Search NTUSER.dat for the key name that contains Dropbox: RECmd.exe -f \"C:\\Temp\\NTUSER.dat\" --sk Dropbox. Search UsrClass.dat for the key value that contains Dropbox: RECmd.exe -f \"C:\\Temp\\UsrClass.dat\" --sd Dropbox. Search the directory registry_files for the key value that contains Dropbox. The last write time is >= StartDate, and the value name contains either AppName or DisplayName, so don't recover deleted keys and don't process log files: RECmd.exe --d \"C:\\Temp\\registry_files\" --sk \"Dropbox\" --StartDate \"11/13/2014 15:35:01\" --RegEx --sv \"(App|Display)Name\" --recover false --nl", "metadata": {"source": "SANS_Command_Line", "title": "RECmd Basic Usage", "category": "dfir", "platform": "windows"}}
{"text": "RECmd Search Options. StartDate: Start date for last write timestamps (UTC). EndDate: End date for last write timestamps (UTC). MinSize: Find values with data size >= MinSize (specified in bytes). --sk: Search for <string> in key names. --sv: Search for <string> in value names. --sd: Search for <string> in value record's value data. --ss: Search for <string> in value record's value slack. Regular expressions must of course be valid .net regular expressions. If either the key or value has spaces in them, enclose in quotes. To get default values, use a value name of (default). --sX are search options; they use the contains logic. --sd will convert the compare values to ASCII and Unicode before doing comparison unless the --l literal switch is used.", "metadata": {"source": "SANS_Command_Line", "title": "RECmd Search Options", "category": "dfir", "platform": "windows"}}
{"text": "RECmd Advanced Usage - Malware Detection. Looking for large registry key (1MB and base64 encoded) that often contain malware. Deleted keys are also retrieved and parsed: RECmd.exe -d \"C:\\Temp\\registry_files\" --minsize 1M --Base64 --recover true. To search for binary data in value data, simply string together the hex characters you want to find, separated by dashes (04-00-EF-BE, for example): RECmd.exe -hive \"C:\\Temp\\registry_files\" --sd \"04-00-EF-BE\"", "metadata": {"source": "SANS_Command_Line", "title": "RECmd Malware Detection", "category": "dfir", "platform": "windows"}}
{"text": "RECmd Batch Mode. To use batch mode, supply the file to the --bn switch, along with --csv to tell RECmd where to save results. Export UserAssist data via RECmd batch file that uses a Registry Explorer plugin: RECmd.exe --bn .\\BatchExamples\\BatchExampleUserAssist.reb -f C:\\Temp\\NTUSER_dblake.DAT --nl --csv C:\\Temp. Export many of the Registry Explorer Plugin CSVs using a batch file: RECmd.exe --bn .\\BatchExamples\\RECmd_Batch_MC.reb -d G:\\blake\\Registry\\E --nl --csv g:\\blake\\recmd_out. When RECmd runs in batch mode, several files will get generated in the --csv directory. By default, batch mode utilizes the same plugins as found in Registry Explorer and works the same way. When used by RECmd, the data from the plugin will be normalized into a standard format for CSV output. When a plugin is used to process a key or key/value, the data generated by the plugin are also saved out to a CSV. In this way, it is very similar to exporting the data from Registry Explorer (albeit to Excel vs. CSV).", "metadata": {"source": "SANS_Command_Line", "title": "RECmd Batch Mode", "category": "dfir", "platform": "windows"}}
{"text": "RECmd Batch File Structure. Header: Description (A general description of what this batch file is going to find), Author (Name of this batch file, can be more like contact information), Version (A version number that should be incremented as changes happen), Id (A unique GUID that identifies this batch file). Keys collection - Each entry consists of: Description (A user-friendly description of what this key will find), HiveType (Valid choices are NTUSER, SAM, SECURITY, SOFTWARE, SYSTEM, USRCLASS, COMPONENTS, BCD, DRIVERS, AMCACHE, SYSCACHE), KeyPath (The path to the key to look for), ValueName (OPTIONAL value that when present is looked for under KeyPath), Recursive (Whether or not to process KeyPath recursively), Comment (Like Description in that you can add various things here that end up in the CSV). HiveType determines which kind of hive the entry corresponds to. This saves time in that RECmd won't search a SOFTWARE hive for keys that won't ever exist (because they are NTUSER-specific, for example).", "metadata": {"source": "SANS_Command_Line", "title": "RECmd Batch File Structure", "category": "dfir", "platform": "windows"}}
{"text": "RECmd Pro Tips. Wildcards are supported in the KeyPath within the batch file. Example: SOFTWARE\\Microsoft\\Office\\*\\*\\User MRU\\*. Detailed, fully functional example batch files can be found in the ZimmermanTools\\RegistryExplorer\\BatchExamples folder. Be as specific as possible about the directory to process as it can have a significant impact on performance. Processing the entire drive is much slower than processing a single user directory. A RECmd batch file can contain instructions for processing different Hives & Keys. Using the -f option allows you to target a specific hive instead of all hives mentioned in the batch file.", "metadata": {"source": "SANS_Command_Line", "title": "RECmd Pro Tips", "category": "dfir", "platform": "windows"}}
{"text": "WxTCmd - Windows Timeline Parser. Type of Artifact: The 1803 update of Windows 10 introduced the Timeline feature. This keeps a record of the last 30 days of applications and files opened by a given user. The data for this are also synchronized from other computers where the user has logged in with their Microsoft account.", "metadata": {"source": "SANS_Command_Line", "title": "WxTCmd - Windows Timeline Parser Overview", "category": "dfir", "platform": "windows"}}
{"text": "WxTCmd Basic Usage and Key Data. WxTCmd takes a single ActivitiesCache.db file as input. Output for this command is not output to the screen, so a CSV needs to be specified: WxTCmd.exe -f E:\\Users\\srogers\\AppData\\Local\\ConnectedDevicesPlatform\\a393c317ac1474e\\ActivitiesCache.db --csv G:\\output. Note that the subfolder named a3936c317ac1474e is not consistent. An equivalent, differently named folder will be present for other users. Key Data Returned: There are several columns of potential interest in a forensic investigation. The Executable column provides the name and the path of the executable in use. For example, Program Files x86\\Adobe\\Acrobat Reader DC\\Reader\\Acrord32.exe would show that Acrobat Reader was opened. Display Text provides information regarding the content opened and the application used. For example, Tax Documents.pdf (Acrobat Reader DC) would indicate that the file Tax Documents.pdf was opened using Acrobat Reader. Content Info provides information relating to the location of the item that was opened. Start Time indicates the first time, in the last 30 days, that this specific activity occurred.", "metadata": {"source": "SANS_Command_Line", "title": "WxTCmd Basic Usage and Key Data", "category": "dfir", "platform": "windows"}}
{"text": "WxTCmd Pro Tip. Among the parsed data provided by WxTCmd is the column named Content Info. As described above, this column contains the location and name of the opened file or resource. However, it also contains another valuable piece of information. If a file was opened from a D: drive, this ActivitiesCache.db file contains information for all computers synchronized to this Microsoft account, so several linked computers could have a D: drive. The example provides the GUID (Global Unique Identifier) for the volume that stores that file. This means that the file can be tied back to a specific volume on a specific device. Example: D:\\Files\\Cat.jpg (file:Unmapped GUID: //D:/Files/Cat.jpgVolumeId={A98818E7-5868-4C06-807E-0F24C9746829}&ObjectId={AE26BE95-ACAC-11E9-B3FB-60F6770E22E2})", "metadata": {"source": "SANS_Command_Line", "title": "WxTCmd Pro Tip - Volume GUID Tracking", "category": "dfir", "platform": "windows"}}
{"text": "SANS DFIR Curriculum. Digital Forensics: FOR308 Digital Forensics Essentials, FOR498 Digital Acquisition and Rapid Triage (GBFA), FOR500 Windows Forensic Analysis (GCFE), FOR518 Mac and iOS Forensic Analysis & Incident Response (GIME), FOR585 Smartphone Forensic Analysis In-Depth (GASF). Incident Response & Threat Hunting: FOR508 Advanced Incident Response, Threat Hunting & Digital Forensics (GCFA), FOR578 Cyber Threat Intelligence (GCTI), SEC504 Hacker Tools, Techniques & Incident Handling (GCIH). Additional Courses: FOR509 Enterprise Cloud Forensics & Incident Response, FOR528 Ransomware for Incident Responders (GCFR), FOR532 Enterprise-Class Incident Response & Threat Hunting, FOR572 Advanced Network Forensics: Threat Hunting, Analysis & Incident Response (GNFA), FOR608 Enterprise Memory Forensics In-Depth, FOR610 REM: Malware Analysis Tools & Techniques (GREM), FOR710 Reverse-Engineering Malware: Advanced Code Analysis.", "metadata": {"source": "SANS_Command_Line", "title": "SANS DFIR Course Curriculum", "category": "dfir", "platform": "windows"}}
{"text": "This poster was created by Mark Hallman and Lee Whitfield with support from the SANS DFIR Faculty. DFPS_Command-Line_v1.6_02-23. The most trusted source for cybersecurity training, certifications, degrees, and research. sans.org/eztools. @SANSForensics. dfir.to/DFIRCast. dfir.to/LinkedIn.", "metadata": {"source": "SANS_Command_Line", "title": "SANS DFPS Command-Line Poster Credits", "category": "dfir", "platform": "windows"}}
