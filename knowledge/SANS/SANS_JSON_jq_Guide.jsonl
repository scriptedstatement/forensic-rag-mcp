{"text": "JSON and jq Quick Start Guide v1.2 - SANS Institute - by Phil Hagen & David Szili", "metadata": {"source": "SANS_JSON_jq", "title": "Document Title and Authors", "category": "reference", "platform": "linux"}}
{"text": "This guide is a supplement to SANS FOR572: Advanced Network Forensics and Analysis. It covers the basics of JSON and some of the fundamentals of the jq utility. The jq utility filters, parses, formats, and restructures JSON—think of it as sed, awk, and grep, but for JSON. Given the trend toward logs being generated in JSON, easily accessing and molding that data is increasingly important for the forensicator.", "metadata": {"source": "SANS_JSON_jq", "title": "Purpose", "category": "reference", "platform": "linux"}}
{"text": "This document is not intended to replace jq's extensive documentation. It is only a quick reference resource.", "metadata": {"source": "SANS_JSON_jq", "title": "Purpose - Scope", "category": "reference", "platform": "linux"}}
{"text": "Stephan Dolan is the developer of jq, which is free and open-source software. You can install jq in most *NIX-based operating systems using the distribution's software/package management system, or you can download the binary for your operating system or the source code from the main project page. Visit for572.com/jq for details, as well as to learn how to contribute to the project through the author's GitHub repository.", "metadata": {"source": "SANS_JSON_jq", "title": "Acquiring the jq Utility", "category": "reference", "platform": "linux"}}
{"text": "A web-based version of jq is hosted at jqplay.org. This is especially helpful while learning jq, as you can experiment with filters and options in a graphical interface. The jqplay.org web implementation can also be hosted in your own environment, making it suitable for air-gapped networks.", "metadata": {"source": "SANS_JSON_jq", "title": "Acquiring the jq Utility - Web Version", "category": "reference", "platform": "linux"}}
{"text": "JSON (JavaScript Object Notation) is an open standard data interchange format, which is both machine-parsable and (mostly) human-readable.", "metadata": {"source": "SANS_JSON_jq", "title": "JSON: Structure for Humans and Machines", "category": "reference", "platform": "linux"}}
{"text": "JSON is built on two primary structures: Key/value pairs and ordered lists of values. Data types for values can consist of strings, numbers, booleans, nested JSON objects, or the null value.", "metadata": {"source": "SANS_JSON_jq", "title": "JSON Data Types", "category": "reference", "platform": "linux"}}
{"text": "A single-field JSON object might look like this: { \"name\": \"Lance\" }", "metadata": {"source": "SANS_JSON_jq", "title": "JSON Single-Field Example", "category": "reference", "platform": "linux"}}
{"text": "A more complex JSON object might look like this: { \"name\": \"Lance\", \"age\": 42, \"active\": true, \"tags\": [ \"tag1\", \"tag2\" ], \"address\": { \"street\": \"123 Main\", \"city\": \"Lewes\", \"state\": \"DE\", \"postalCode\": \"19958\"}, \"pet\": null }", "metadata": {"source": "SANS_JSON_jq", "title": "JSON Complex Object Example", "category": "reference", "platform": "linux"}}
{"text": "JSON can be represented in compact form, as shown above with one object per line, or expanded as shown below – both formats are considered equivalent. Note that tags is an array and address is a nested JSON object.", "metadata": {"source": "SANS_JSON_jq", "title": "JSON Compact vs Expanded Form", "category": "reference", "platform": "linux"}}
{"text": "Sample JSON Record: The following JSON object will be used for all examples. This reflects a single entry from a dns.log file created by the Zeek Network Security Monitoring platform. All examples assume the compact version of this record in a file named dns.log.", "metadata": {"source": "SANS_JSON_jq", "title": "Sample JSON Record - Zeek dns.log", "category": "reference", "platform": "linux"}}
{"text": "In its simplest usage, jq will format compact JSON objects into their expanded form. There are several fundamental command line options that will help you as well. The '.' filter represents the root of each JSON object and will simply display all fields in the object when used.", "metadata": {"source": "SANS_JSON_jq", "title": "Fundamental Usage: Pretty Print", "category": "reference", "platform": "linux"}}
{"text": "jq - Format, filter, and transform JSON data\n$ jq [options] <filter> <input_file>\n-c  Compact output instead of \"pretty-printed\"\n-r  Raw output instead of quoted JSON text\n-S  Sort output lexically based on key names", "metadata": {"source": "SANS_JSON_jq", "title": "jq Command Syntax and Options", "category": "reference", "platform": "linux"}}
{"text": "For example, to print the sample dns.log entry shown in expanded form:\n$ jq '.' dns.log", "metadata": {"source": "SANS_JSON_jq", "title": "jq Pretty Print Example", "category": "reference", "platform": "linux"}}
{"text": "Many times, the user only needs to display specific fields from each JSON object instead of the entire set. This requires a more detailed filter statement.", "metadata": {"source": "SANS_JSON_jq", "title": "Filtering: Just the Field You Want", "category": "reference", "platform": "linux"}}
{"text": "To display the value for just one field, identify the field with the '.<fieldname>' syntax (note the leading dot).\n$ jq '.query' dns.log\n\"www.sansgear.com\"", "metadata": {"source": "SANS_JSON_jq", "title": "jq Single Field Filter Syntax", "category": "reference", "platform": "linux"}}
{"text": "To display resulting values in their non-quoted raw form, use the -r option to the jq command.\n$ jq -r '.query' dns.log\nwww.sansgear.com", "metadata": {"source": "SANS_JSON_jq", "title": "jq Raw Output Option", "category": "reference", "platform": "linux"}}
{"text": "When referencing a field name that contains any non-alphanumeric character, double quotation marks must be used. This is common with the dot character, which designates nested JSON objects. However, some JSON logs such as Zeek's use it as a part of the field name which then requires double quoting.\n$ jq '.\"id.orig_h\"' dns.log\n\"192.168.75.169\"", "metadata": {"source": "SANS_JSON_jq", "title": "jq Field Names with Special Characters", "category": "reference", "platform": "linux"}}
{"text": "To access a particular element from an array, familiar [<element_number>] notation is used. Remember that array indices are zero-based.\n$ jq '.answers[0]' dns.log\n\"vhost1.identityvector.com\"", "metadata": {"source": "SANS_JSON_jq", "title": "Accessing Array Elements", "category": "reference", "platform": "linux"}}
{"text": "Nested objects can be accessed by using the dot separator. While the sample Zeek dns.log entry does not contain these, the below example uses the original JSON object from this handout with the shell's pipe operator to show that like many other command-line tools, jq can be used with data on STDIN instead of a file.", "metadata": {"source": "SANS_JSON_jq", "title": "Accessing Nested JSON Objects", "category": "reference", "platform": "linux"}}
{"text": "$ echo '{ \"name\": \"Lance\", \"age\": 42, \"active\": true, \"tags\": [ \"tag1\", \"tag2\" ], \"address\": { \"street\": \"123 Main\", \"city\": \"Lewes\", \"state\": \"DE\", \"postalCode\": \"19958\"}, \"pet\": null }' | jq '.address.city'\n\"Lewes\"", "metadata": {"source": "SANS_JSON_jq", "title": "Accessing Nested JSON Objects - Example", "category": "reference", "platform": "linux"}}
{"text": "To select more than one field, the syntax reflects assembling a new JSON object. No leading dot is used in this filter syntax. Note that the -r option has no effect.\n$ jq '{ \"id.orig_h\", query }' dns.log\n{\n  \"id.orig_h\": \"192.168.75.169\",\n  \"query\": \"www.sansgear.com\"\n}", "metadata": {"source": "SANS_JSON_jq", "title": "Complex Filtering: Build New JSON Objects", "category": "reference", "platform": "linux"}}
{"text": "By default, jq will process all JSON objects in the input data set. Using the select operator allows you to limit the records processed based on their values.\n$ jq 'select(.rcode_name == \"NOERROR\")'\nThis command will produce all records with a value of \"NOERROR\" in the rcode_name field.", "metadata": {"source": "SANS_JSON_jq", "title": "Selecting Records Based on Content", "category": "reference", "platform": "linux"}}
{"text": "The additional operators contains, startswith, and endswith are also useful ways to select records.\n$ jq 'select(.query | contains(\"sans\"))' dns.log\n$ jq 'select(.query | endswith(\".com\"))' dns.log", "metadata": {"source": "SANS_JSON_jq", "title": "jq Select Operators - contains, startswith, endswith", "category": "reference", "platform": "linux"}}
{"text": "Note however, that the select() operator can be very slow, especially on large data sets. Using a preprocessor such as grep (or zgrep for gzip-compressed JSON) can provide a dramatic performance improvement.", "metadata": {"source": "SANS_JSON_jq", "title": "jq Select Performance Note", "category": "reference", "platform": "linux"}}
{"text": "The pipe symbol, |, can be used in the filter statement to pass the output of one operation to the input of the next.\n$ jq 'select(.rcode_name == \"NOERROR\") | .query' dns.log\n\"www.sansgear.com\"", "metadata": {"source": "SANS_JSON_jq", "title": "Chaining jq Operations", "category": "reference", "platform": "linux"}}
{"text": "Many logs use a form of the UNIX Epoch timestamp. Rather than use external conversion utilities, jq can convert these natively. (The | operator passes output from one part of the filter as input to the next and |= replaces a field's value in place.)\n$ jq '.ts |= todate | .ts' dns.log\n\"2020-10-09T17:50:24Z\"", "metadata": {"source": "SANS_JSON_jq", "title": "Reformatting Time Stamps", "category": "reference", "platform": "linux"}}
{"text": "Zeek dns.log fields: ts (timestamp), uid (unique connection ID), id.orig_h (originating host IP), id.orig_p (originating port), id.resp_h (responding host IP), id.resp_p (responding port), proto (protocol), trans_id (transaction ID), rtt (round trip time), query (DNS query), qclass (query class), qclass_name (query class name), qtype (query type), qtype_name (query type name), rcode (response code), rcode_name (response code name), AA (authoritative answer), TC (truncated), RD (recursion desired), RA (recursion available), Z (reserved), answers (DNS answers array), TTLs (time to live array), rejected (query rejected flag)", "metadata": {"source": "SANS_JSON_jq", "title": "Zeek dns.log Field Reference", "category": "reference", "platform": "linux"}}
