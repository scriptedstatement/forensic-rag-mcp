{"text": "M = mtime Modified: Data content change time. Time the file data was last modified", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamps - mtime", "category": "dfir", "platform": "linux"}}
{"text": "A = atime Accessed: Data last access time. Approximate time when the file data was last accessed for some reason, not necessarily by the user. Not reliable", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamps - atime", "category": "dfir", "platform": "linux"}}
{"text": "C = ctime Changed Metadata: Metadata change time. The time the inode entry was last updated", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamps - ctime", "category": "dfir", "platform": "linux"}}
{"text": "B = btime = crtime Birth: File creation time. Time file was created on this filesystem. Not always recorded", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamps - btime", "category": "dfir", "platform": "linux"}}
{"text": "File Creation: M set to time of creation, A set to time of creation, C set to time of creation, B set to time of creation", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamp Rules - File Creation", "category": "dfir", "platform": "linux"}}
{"text": "File Access: M no change, A set to time of access (controlled by atime settings when filesystem is mounted), C no change, B no change", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamp Rules - File Access", "category": "dfir", "platform": "linux"}}
{"text": "Content Change: M set to time of change, A set to time of change (controlled by atime settings), C set to time of change, B no change", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamp Rules - Content Change", "category": "dfir", "platform": "linux"}}
{"text": "File Copy: M set to time of copy, A set to time of copy, C set to time of copy, B set to time of copy. These timestamps are for the new file. The source file may have an atime change.", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamp Rules - File Copy", "category": "dfir", "platform": "linux"}}
{"text": "File Move Rename: M no change, A no change, C set to time of move, B no change", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamp Rules - File Move Rename", "category": "dfir", "platform": "linux"}}
{"text": "File Move (New Mount Point): M no change, A no change, C set to time of move, B set to time of move", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamp Rules - File Move New Mount Point", "category": "dfir", "platform": "linux"}}
{"text": "File Delete: M set to time of deletion, A no change, C set to time of deletion, B no change. This varies by filesystem type. XFS does not set the mtime. EXT stores a 32-bit deletion timestamp. XFS does not.", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timestamp Rules - File Delete", "category": "dfir", "platform": "linux"}}
{"text": "EXT3: Theoretical Maximum Single-File Size 2 TiB, Maximum Filesystem Size 16 TiB, Timestamps 32-bit no crtime subject to 2038 timestamp issue, Journal Yes, Notes Older found on infrastructure", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Characteristics - EXT3", "category": "dfir", "platform": "linux"}}
{"text": "EXT4: Theoretical Maximum Single-File Size 16 TiB, Maximum Filesystem Size 1 EiB, Timestamps 64-bit crtime subject to 2446 timestamp issue, Journal Yes, Notes Default on Debian family", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Characteristics - EXT4", "category": "dfir", "platform": "linux"}}
{"text": "XFS: Theoretical Maximum Single-File Size 8 EiB, Maximum Filesystem Size 8 EiB, Timestamps 64-bit crtime subject to 2446 timestamp issue, Journal Yes, Notes Default on RHEL family", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Characteristics - XFS", "category": "dfir", "platform": "linux"}}
{"text": "BTRFS: Theoretical Maximum Single-File Size 16 EiB, Maximum Filesystem Size 16 EiB, Timestamps 64-bit crtime subject to 2446 timestamp issue, CoW, Notes Found on NAS devices and some Fedora/SUSE versions", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Characteristics - BTRFS", "category": "dfir", "platform": "linux"}}
{"text": "ZFS: Theoretical Maximum Single-File Size 16 EiB, Maximum Filesystem Size 256 ZiB, Timestamps True 64-bit crtime not subject to 2446 timestamp issue, CoW, Notes Sometimes found on HPC/Unix systems", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Characteristics - ZFS", "category": "dfir", "platform": "linux"}}
{"text": "UFS1: Theoretical Maximum Single-File Size 8 ZiB, Maximum Filesystem Size 8 ZiB, Timestamps 32-bit no crtime, Journal No, Notes Mainly used on Unix systems", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Characteristics - UFS1", "category": "dfir", "platform": "linux"}}
{"text": "UFS2: Theoretical Maximum Single-File Size 8 ZiB, Maximum Filesystem Size 8 ZiB, Timestamps True 64-bit crtime, Journal No, Notes Mainly used on Unix systems", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Characteristics - UFS2", "category": "dfir", "platform": "linux"}}
{"text": "BLOCK: An area of storage space that is the smallest accessible unit on a filesystem", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Terminology - Block", "category": "dfir", "platform": "linux"}}
{"text": "EXTENT: A group of consecutive blocks", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Terminology - Extent", "category": "dfir", "platform": "linux"}}
{"text": "INODE: An index node. This stores file metadata and its location on the drive", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Terminology - Inode", "category": "dfir", "platform": "linux"}}
{"text": "BLOCK GROUPS: Groups of blocks containing filesystem-related information", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Terminology - Block Groups", "category": "dfir", "platform": "linux"}}
{"text": "SUPERBLOCK: The block that contains the filesystem metadata that defines other structures", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Terminology - Superblock", "category": "dfir", "platform": "linux"}}
{"text": "INODE BITMAP: Records which inodes are in use within a group and the locations of the data block", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Filesystem Terminology - Inode Bitmap", "category": "dfir", "platform": "linux"}}
{"text": "mmls [image] - Review an image to understand its structure", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - mmls", "category": "dfir", "platform": "linux"}}
{"text": "fsstat -f [filesystem] -I [image type] [image] - Identify the layout of a filesystem", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - fsstat", "category": "dfir", "platform": "linux"}}
{"text": "fls -r -m [image] - Extract all filesystem timestamps for a timeline", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - fls timeline", "category": "dfir", "platform": "linux"}}
{"text": "fcat [file path] [image] - Read the contents of a file with a given filename", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - fcat", "category": "dfir", "platform": "linux"}}
{"text": "icat [image] [inode] - Read the contents of a file at a given inode", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - icat", "category": "dfir", "platform": "linux"}}
{"text": "istat [image] [inode] - Review the metadata of a file", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - istat", "category": "dfir", "platform": "linux"}}
{"text": "blkcat [image] [block number] - Extract the contents of a data block", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - blkcat", "category": "dfir", "platform": "linux"}}
{"text": "ffind [image] [inode] - Identify the filename for a given inode", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - ffind", "category": "dfir", "platform": "linux"}}
{"text": "ifind [image] -n [file path] - Identify the inode for a given filename", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - ifind", "category": "dfir", "platform": "linux"}}
{"text": "mmcat [image] [partition number] > [file] - Extract an individual disk partition", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - mmcat", "category": "dfir", "platform": "linux"}}
{"text": "ils -m [image] - List unallocated inodes in Mactime format", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - ils", "category": "dfir", "platform": "linux"}}
{"text": "fls -Frd [image] - List all deleted regular files and their inodes", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "TSK Command - fls deleted", "category": "dfir", "platform": "linux"}}
{"text": "Incident Response Process: Preparation -> Detection and Intelligence Loop -> Identification and Scoping -> Containment -> Eradication -> Recovery -> Lessons Learned", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Incident Response Process", "category": "dfir", "platform": "linux"}}
{"text": "Common Mistakes: Rushing the identification and scoping phase means you don't know the extent of the compromise. Skipping containment allows the attackers to pivot. Hasty actions can alert the attackers to change tactics and rarely leads to complete eradication. Business pressure to return to normal creates a rush to get to remediation, even if other stages are incomplete.", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Incident Response Common Mistakes", "category": "dfir", "platform": "linux"}}
{"text": "Do not react too quickly to an incident. Teams need to move towards intelligence-driven incident response", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Incident Response Guidance", "category": "dfir", "platform": "linux"}}
{"text": "apt = Advanced Package Tool. Default on Ubuntu systems. Tool for Debian systems. Acts as a front end for Debian packages. Manages dependencies. Repository list (includes default repos): /etc/apt/sources.list. User-added repository lists: /etc/apt/sources.list.d/*.list", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - apt", "category": "dfir", "platform": "linux"}}
{"text": "dpkg = Debian Package. Low-level tool for Debian systems. Does not manage dependencies. Typically used for the installation of standalone packages (.deb files). In general, .deb files are not digitally signed; trust is placed on the repository.", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - dpkg", "category": "dfir", "platform": "linux"}}
{"text": "dpkg commands: View contents of .deb file: ar -tv [package]. List contents of data.tar.* sub-file: dpkg -c [package]. Extract contents of .deb file: ar -xov [package]. Extract contents of data.tar.* sub-file: dpkg -x [package]. Display metadata: dpkg -l [package]. Note: ar tool may not be installed by default; install binutils package.", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - dpkg commands", "category": "dfir", "platform": "linux"}}
{"text": "rpm = RPM Package Manager. Low-level tool for Red Hat-based distros. Found on RHEL/CentOS. Does not manage dependencies. Effectively equivalent to dpkg on Debian. Convert .rpm to .cpio: rpm2cpio [RPM file] > [CPIO file]. View .cpio contents: cpio -i -tv < [CPIO file]. Extract individual file from .cpio: cpio -i --to-stdout [file] < [CPIO file]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - rpm", "category": "dfir", "platform": "linux"}}
{"text": "yum = Yellowdog Updated, Modified. Default on Red Hat Enterprise Linux and CentOS. High-level wrapper for the rpm tool. Manages dependencies. Python 2-based tool with some additional libraries. Repository lists (includes default repos): /etc/yum.repos.d/*.repo", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - yum", "category": "dfir", "platform": "linux"}}
{"text": "dnf = Dandified YUM. Default on Fedora. Rewrite of yum. Manages dependencies. Uses libdnf framework, librepo, and libcomps. Repository lists (includes default repos): /etc/yum.repos.d/*.repo", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - dnf", "category": "dfir", "platform": "linux"}}
{"text": "apk = Alpine Package Keeper. Lightweight package management tool used on Alpine Linux. Designed for use in low-resource environments such as containers. Manages dependencies", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - apk", "category": "dfir", "platform": "linux"}}
{"text": "snap: App Store and package manager developed by Canonical. Snap applications run in a sandbox environment with limited access to the host. Self-contained compressed filesystem using SquashFS", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - snap", "category": "dfir", "platform": "linux"}}
{"text": "synaptic: GUI for APT. Used on Debian systems. Uses deb and rpm packages. Less common than snap", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - synaptic", "category": "dfir", "platform": "linux"}}
{"text": "zypper = Zen/YaST Packages Patches Patterns Products. Command-line interface for YaST (Yet another setup tool). Uses rpm-based packages. Found on openSUSE and SUSE Linux Enterprise. Repository lists (includes default repos): /etc/zypp/repos.d/*", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Package Manager - zypper", "category": "dfir", "platform": "linux"}}
{"text": "Threat Hunting Package Managers: Review all installed applications - Look for random or short (1-2 character) application names, Look for application names that relate to known indicators, Look for applications installed during any time period of interest, Look for unusual repository use", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Threat Hunting - Package Managers Overview", "category": "dfir", "platform": "linux"}}
{"text": "Threat Hunting Package Managers: Review individual packages - Check internal file timestamps, Check any signatures; they should be intact, valid, and expected, Review any pre- or post-installation scripts to check for unusual behavior. Extract individual installer files and review them", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Threat Hunting - Package Review", "category": "dfir", "platform": "linux"}}
{"text": "awk: Powerful data manipulation and pattern matching", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - awk", "category": "dfir", "platform": "linux"}}
{"text": "cat: Concatenate files or display text", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - cat", "category": "dfir", "platform": "linux"}}
{"text": "column: Format output with columns. -t Table format output. -s Specify an input separator (default is whitespace). -o Specify an output separator (default is two spaces). -J JSON output (requires column names). -N Specify column names with comma-separated list for table header. -n Provide a name for the table (default is table)", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - column", "category": "dfir", "platform": "linux"}}
{"text": "cut: Slice input to get the bits you want. -d Use this as a delimiter to cut on. -f Select this field or combination of fields", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - cut", "category": "dfir", "platform": "linux"}}
{"text": "date: Print or set the system time. -d [STRING] Display the date referenced by STRING, not now. -u Display the time in UTC", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - date", "category": "dfir", "platform": "linux"}}
{"text": "file: Check the file's file signature. -z Look inside zip files/compressed archives", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - file", "category": "dfir", "platform": "linux"}}
{"text": "grep: Search file contents for a pattern match. -r Search recursively. -i Case-insensitive search. -o Print only the matched [non-empty] parts of a matching line. -v Exclude matches. -E Pattern match to an extended regular expression. -a Force grep to treat all input as ASCII. -A# Show # lines after the matching line. -B# Show # lines before the matching line. -C# Show # lines before and after the matching line", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - grep", "category": "dfir", "platform": "linux"}}
{"text": "head: Show the first N lines of a file. -n # Show # number of lines. -c # Show # number of bytes", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - head", "category": "dfir", "platform": "linux"}}
{"text": "hexdump: Display file contents in hex (or octal etc.). -C Canonical hex + ASCII display, similar output to xxd. -n [number] Interpret only [number] bytes of input. -s [number] Skip [number] of bytes from the start", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - hexdump", "category": "dfir", "platform": "linux"}}
{"text": "kill: Signal process. -s Send a specific signal name or number. -1 Send the signal to all processes with a PID greater than 1. -l Print a list of signal names", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - kill", "category": "dfir", "platform": "linux"}}
{"text": "ls: List directory contents. -a Show hidden files. -l Use long format and show more details. -h Use human-readable numbers; 1024 = 1k, etc. -i Show inode numbers", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - ls", "category": "dfir", "platform": "linux"}}
{"text": "man: Display the manual for a command. -k [keyword] Search the manual pages for entries that refer to the keyword. -f [command] Display a concise description of the command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - man", "category": "dfir", "platform": "linux"}}
{"text": "md5sum filename: Generate an MD5 hash of filename", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - md5sum", "category": "dfir", "platform": "linux"}}
{"text": "sha1sum filename: Generate a SHA1 hash of filename", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - sha1sum", "category": "dfir", "platform": "linux"}}
{"text": "sha256sum filename: Generate a SHA256 hash of filename", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - sha256sum", "category": "dfir", "platform": "linux"}}
{"text": "sort: Takes input and sends to stdout in order. -r Reverse the sort order. -n Compare strings based on numeric value. -b Ignore leading blanks. -u Suppress all but one in each set where keys are equal", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - sort", "category": "dfir", "platform": "linux"}}
{"text": "tail: Show the last N lines of a file. -n # Show # number of lines. -c # Show # number of bytes", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - tail", "category": "dfir", "platform": "linux"}}
{"text": "tar: Manage archives. -tf [file] List the contents of [file] archive. -xf [file] Extract the contents of [file] archive", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - tar", "category": "dfir", "platform": "linux"}}
{"text": "uniq: Removes duplicate adjacent lines. -d Only return the duplicate lines. -c Count the number of occurrences. -i Ignore the case", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - uniq", "category": "dfir", "platform": "linux"}}
{"text": "wc: Count the number of bytes, lines, or words in a file. -l Show the number of lines. -c Show the number of bytes. -w Show the number of words. -m Show the number of characters", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - wc", "category": "dfir", "platform": "linux"}}
{"text": "xxd: Making hexdumps. -s [number] Start [number] bytes into the file (seek). -l [number] Show [number] bytes in total (length). -r Convert hexdump back into a binary format (reverse)", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - xxd", "category": "dfir", "platform": "linux"}}
{"text": "zcat: Read compressed files. -d Decompress the file. -r Recurse through directories", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - zcat", "category": "dfir", "platform": "linux"}}
{"text": "zgrep: Search compressed data sets", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Command - zgrep", "category": "dfir", "platform": "linux"}}
{"text": "Regex metacharacters: . Match any single character, except a newline. ^ Anchor the match at the start of a line. $ Anchor the match at the end of a line. * Match the preceding element zero or more times. + Match the preceding element one or more times. ? Match the preceding element zero or one time", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Regex Metacharacters Part 1", "category": "dfir", "platform": "linux"}}
{"text": "Regex metacharacters: [ ] Match any one of the characters inside the brackets. A range of characters can be specified using a hyphen. Example [a-z]. | Acts as a logical OR between patterns. ( ) Group parts of a pattern together. Escape a metacharacter to search for the literal character using backslash (\\)", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Regex Metacharacters Part 2", "category": "dfir", "platform": "linux"}}
{"text": "dd: Installed by default in most distros. Usage: dd if=[input file] of=[output file] bs=[blocksize] conv=sync,noerror", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Disk Evidence Collection - dd", "category": "dfir", "platform": "linux"}}
{"text": "dcfldd: Not installed by default. Forked version of dd. Usage: dcfldd if=[input file] of=[output file] hash=[hash format] hashlog=[hashlog file] conv=sync,noerror", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Disk Evidence Collection - dcfldd", "category": "dfir", "platform": "linux"}}
{"text": "dc3dd: Not installed by default. Patched, more verbose version of dd. Usage: dc3dd if=[input file] of=[output file] hash=[hash format] hlog=[hashlog file] log=[diagnostic log file]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Disk Evidence Collection - dc3dd", "category": "dfir", "platform": "linux"}}
{"text": "ewfacquire: Not installed by default. Part of libewf. Writes E01 format files. Usage: ewfacquire [device]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Disk Evidence Collection - ewfacquire", "category": "dfir", "platform": "linux"}}
{"text": "dd over ssh: On the source system: dd if=[input file] | ssh [username]@[ip address] \"dd of=[output file] bs=[blocksize] conv=sync,noerror\"", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Remote Collection - dd over ssh", "category": "dfir", "platform": "linux"}}
{"text": "dd image sent to a Google Cloud Platform storage bucket: On the source system: dd if=[input file] bs=[blocksize] | gzip | gsutil cp - gs://[bucketname/objectname]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Remote Collection - dd to GCP", "category": "dfir", "platform": "linux"}}
{"text": "dd over netcat: On the source system: dd if=[input file] bs=[blocksize] | bzip2 -c | nc [ip address] [port]. On the destination system: nc -nvlp [port] | bzip2 -d | dd bs=[blocksize] of=[output file]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Remote Collection - dd over netcat", "category": "dfir", "platform": "linux"}}
{"text": "Acquire Volatile Memory for Linux (AVML): Open-source tool written in Rust, available from https://github.com/microsoft/avml. Does not require on-target compilation of the binary. Includes support for various cloud platforms, such as AWS, Microsoft Azure, and Google Cloud, to store memory images. Supports compression of memory images using the --compress option. Usage: avml [output file]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Memory Acquisition - AVML", "category": "dfir", "platform": "linux"}}
{"text": "Loadable Kernel Module (LiME): Requires on-target compilation of the binary, or can be compiled externally using the same distro version and kernel release and build process as the target, but this can be complicated. This project is no longer maintained", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Memory Acquisition - LiME", "category": "dfir", "platform": "linux"}}
{"text": "Direct access to the system's physical memory in /dev/mem: Direct access to physical memory on a running system can potentially cause system crashes or other damage. When power is lost, this ceases to exist and is not recovered in standard disk images", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Memory Acquisition - /dev/mem", "category": "dfir", "platform": "linux"}}
{"text": "/proc virtual filesystem process entries: cmdline - process command line and any arguments, use cat to view. comm - process command name; similar to cmdline but doesn't include the name of any application that called the process, use cat to view. cwd - current working directory that the process is running in, use ls to view. environ - process environment assigned to the running application, use cat to view", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "/proc Process Entries Part 1", "category": "dfir", "platform": "linux"}}
{"text": "/proc virtual filesystem process entries: exe - symbolic link to the executable running the process, use ls to view. fd - folder containing details on where the file descriptors are pointing, use ls -al to view. map_files - folder containing links to shared objects and memory-mapped files used by the application, use ls -al to view. maps - file that contains similar information to the map_files folder, use cat to view", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "/proc Process Entries Part 2", "category": "dfir", "platform": "linux"}}
{"text": "/proc virtual filesystem process entries: mountinfo - file that holds information about any active mount points, use cat to view. net - directory containing networking information for the process, includes TCP/UDP ports, route tables, and network statistics, use ls to view. root - link to the root folder for this application, useful for identifying applications running in unusual environments such as chroot, use ls -al to view", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "/proc Process Entries Part 3", "category": "dfir", "platform": "linux"}}
{"text": "/proc virtual filesystem process entries: sched - file containing the CPU scheduling parameters as they apply to the PID being reviewed, use cat to view. stack - file that describes the current kernel stack of the process being reviewed, use cat to view. status - file containing the current status of a process, use cat to view. Status values: running (active), sleeping (waiting for an event or resource), zombie (process completed execution but not yet fully exited the process list)", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "/proc Process Entries Part 4", "category": "dfir", "platform": "linux"}}
{"text": "/proc filesystem: Information is provided in real time and is dynamically updated by the kernel. Can use filesystem tools to analyze. When power is lost, this ceases to exist and is not recovered in standard disk images. /proc/kcore is a snapshot of kernel and physical memory", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "/proc Filesystem Overview", "category": "dfir", "platform": "linux"}}
{"text": "Host-based enterprise DFIR agent software: Provides connection from investigator to target host system. Can run processes on the target host and send data back to the investigator. Restricted by host system resources and network bandwidth", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Remote Collection - DFIR Agents", "category": "dfir", "platform": "linux"}}
{"text": "Endpoint Detection and Response (EDR) Tools: Uses a host-based agent. Most EDR products function as remote analysis tools run from a central management console. Enables continuous monitoring of activity on endpoints. EDR solutions are not forensic tools - They rarely protect metadata, have constraints around artifacts they can access, and often allow live response, which generates new artifacts and potentially destroys evidence. Needs knowledgeable and skilled analysts to drive value. It is rare to find EDR on Linux-based infrastructure. Alternatives to commercial EDR platforms include OSSEC and Velociraptor", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Remote Collection - EDR Tools", "category": "dfir", "platform": "linux"}}
{"text": "Sysmon for Linux: Not yet widely deployed in commercial enterprises. Requires deployment and maintenance of an agent on the endpoint. Logs it generates need to be collected and analyzed somewhere. Sysmon works by monitoring system activity (effectively API calls) and logging events based on user-defined rules. Sysmon for Linux logs events in a variety of formats, including JSON and Syslog. To install Sysmon on Linux, you need to get the Microsoft signing key and add that to your distro's package management tool, before updating the package manager. Sysmon is configured using a YAML format file that contains the rules to implement. Confirm which event IDs are recorded by your version of Sysmon by running the sysmon -s command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Remote Collection - Sysmon for Linux", "category": "dfir", "platform": "linux"}}
{"text": "Commercial Forensic Suites: Full forensic suites use host-based agents. Can deliver incredible analytical capabilities but often need significant resources. Check that the distro in use is supported; capabilities vary", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Remote Collection - Commercial Forensic Suites", "category": "dfir", "platform": "linux"}}
{"text": "C# Live Response (CyLR): Open-source tool for rapid collection of triage data and forensic evidence. Runs from a pre-compiled binary that can be dropped in the target environment. Retains metadata. CyLR needs to be run as root on the target system. No longer under development", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Triage Collection - CyLR", "category": "dfir", "platform": "linux"}}
{"text": "Google Rapid Response (GRR): Open-source IR framework from Google designed for forensics at scale. Uses a client-server model and provides a dashboard for monitoring. Can work well for a limited set of use cases. Recommended deployment of GRR is via Docker", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Triage Collection - GRR", "category": "dfir", "platform": "linux"}}
{"text": "Unix-like Artifacts Collector (UAC): Open-source tool to gather triage data from Unix-based systems, such as Linux, macOS, and FreeBSD. Uses binaries already on the host system, so compromised binaries may result in incorrect or omitted output. Respects the Order of Volatility. Can also capture RAM. Includes support to write output to various cloud platforms. Collect artifacts in a profile: uac -p [collection profile] [output dir]. Collect specific artifacts: uac -a [artifacts] [output dir]. Collect data from a mounted volume: uac [-p|-a] [profile|artifacts] [output dir] --mount-point [mount point]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Triage Collection - UAC", "category": "dfir", "platform": "linux"}}
{"text": "Velociraptor: Open-source EDR-like tool with exceptional forensic collection capabilities. It is easy to deploy and configurable. Triage collection can be achieved using an offline collector or via the stand-alone query mode", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Triage Collection - Velociraptor", "category": "dfir", "platform": "linux"}}
{"text": "Dissect: Open-source forensic collection and analysis framework developed by Fox-IT. It is easy to use and configurable. Tool allows for collection (Acquire) and analysis (Dissect). These two components need to be installed separately. Running Acquire requires elevated privileges for full functionality and to read raw disk data. Default behavior of Acquire runs against the local host. Acquire a target: acquire -p [profile] -o [output dir] [target]. Extract information from evidence: target-query -q -f [functions to run] [evidence]. Run command on evidence: target-fs -q [evidence] [command] [path to run command against]. Mount evidence: target-mount -q [evidence] [mount point]. Open virtual shell environment on evidence: target-shell -q [evidence]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Triage Collection - Dissect", "category": "dfir", "platform": "linux"}}
{"text": "Creating a Filesystem Timeline Step 1: Create a bodyfile. From a simple source image: fls -a -r -m [path prefix] [source image] > [bodyfile]. From a complex source image: fls -a -r -m [path prefix] -I [image format] -om [partition offset] [source image] > [bodyfile]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timelining - Create Bodyfile", "category": "dfir", "platform": "linux"}}
{"text": "Creating a Filesystem Timeline Step 2: Convert to human-readable format. Convert to CSV: mactime -d -z UTC -b [bodyfile] [time slice] > [timeline.csv]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Timelining - Convert Bodyfile", "category": "dfir", "platform": "linux"}}
{"text": "Creating a Super Timeline Option 1: psteal. psteal.py --source [source image] -o [output format] -w [output file]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Super Timeline - psteal", "category": "dfir", "platform": "linux"}}
{"text": "Creating a Super Timeline Option 2: log2timeline and psort. Extract events from image into storage file: log2timeline.py --storage-file [storage file] [source image]. Create a human-readable timeline from the storage file: psort.py -w [output file] [storage file] [event filter]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Super Timeline - log2timeline and psort", "category": "dfir", "platform": "linux"}}
{"text": "Computer Name: The computer name, or hostname, is stored in a plaintext file in the /etc folder. Location: /etc/hostname. This file can be read with any text editor or via the cat command. Live response commands to identify the hostname: hostname, hostname --fqdn, hostname --long", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - Computer Name", "category": "dfir", "platform": "linux"}}
{"text": "Hosts File: The hosts file is used to map IP addresses with hostnames and takes precedence over a DNS lookup. Location: /etc/hosts. Check the hosts file for anything that may have been added/changed by an attacker, or if it provides any clues or visibility into the environment", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - Hosts File", "category": "dfir", "platform": "linux"}}
{"text": "Timezone: Only the device's current timezone setting is stored in these files. Location: /etc/timezone, /etc/localtime (symbolic link). timezone can be read with any text editor or via the cat command. localtime can be read using the ls -l command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - Timezone", "category": "dfir", "platform": "linux"}}
{"text": "Distro Information: The Linux distro name and version number are often recorded in multiple ways and formats, depending on the distro. Location: /etc/os-release. On Ubuntu (and Debian-based distros): /etc/lsb-release", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - Distro Information Location", "category": "dfir", "platform": "linux"}}
{"text": "Distro Information RHEL/CentOS-based distros: For RHEL systems: /etc/redhat-release. For Fedora systems: /etc/fedora-release. For CentOS systems: /etc/centos-release. For Rocky Linux systems: /etc/rocky-release. For Amazon Linux systems: /etc/system-release. For Oracle Linux systems: /etc/oracle-release and /etc/redhat-release. For SLES systems: /etc/SuSE-release (older) or /etc/SUSE-brand (newer)", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - RHEL Distro Locations", "category": "dfir", "platform": "linux"}}
{"text": "os-release key fields: NAME - The distro name, defined by the creator/release organization. VERSION - Version number and name, if appropriate. ID - Also the distro name, but often in an abbreviated form. ID_LIKE - The distro family. PRETTY_NAME - A human-readable string describing the distro and version number. VERSION_ID - A shortened representation of the version string", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - os-release Fields", "category": "dfir", "platform": "linux"}}
{"text": "lsb-release key fields: DISTRIB_ID - The distro name. DISTRIB_RELEASE - The release or version number of the distro. DISTRIB_CODENAME - The codename associated with the distro release. DISTRIB_DESCRIPTION - A human-readable description of the distro, combining the name, version, and codename", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - lsb-release Fields", "category": "dfir", "platform": "linux"}}
{"text": "Live response commands to identify distro information: lsb_release -a (Note: not available on default Fedora or RHEL/CentOS 7+ distros). hostnamectl. On remote systems (connecting via SSH): hostnamectl -H [user]@[IP address]. cat /proc/version", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - Live Distro Commands", "category": "dfir", "platform": "linux"}}
{"text": "Partition Information: Information about partitions currently present on the system's block devices, such as hard drives and flash drives, is available under the /proc virtual filesystem. This only exists while the system is live. Location: /proc/partitions. Plaintext file; view using the cat command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - Partition Information", "category": "dfir", "platform": "linux"}}
{"text": "Mount Points: Information about the filesystems currently mounted in the live system, including their device, mount point, filesystem type, mount options, and other details, is present in a virtual file. This only exists while the system is live. Location: /proc/mounts. Plaintext file; view using the cat command. Does not provide a historical record for previously mounted filesystems", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Device Profiling - Mount Points", "category": "dfir", "platform": "linux"}}
{"text": "Kernel Messages (dmesg): The Kernel Messages log contains information related to the boot process of the system, generated by the kernel and device drivers. The name dmesg comes from Diagnostic Messages. Entries in this log provide information about hardware and device initialization. Location: /var/log/dmesg. Also, on Ubuntu 22.04 and older: /var/log/kern.log", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "System Logs - Kernel Messages dmesg", "category": "dfir", "platform": "linux"}}
{"text": "dmesg interpretation: The dmesg file is written at the end of the system startup cycle. The log is stored in a buffer in the kernel and can be viewed using the dmesg command on a live system. RHEL8/CentOS8 (Fedora 28), and Ubuntu 24.04 or newer, no longer include this service by default; dmesg events are written to the system journal and can still be viewed with the dmesg command, but there is no /var/log/dmesg file. Includes entries relating to USB devices or drive activity", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "System Logs - dmesg Interpretation", "category": "dfir", "platform": "linux"}}
{"text": "Boot History: Linux distros maintain a record of scripts run and events that fire during the boot process, in log files. This therefore logs the last time the system was booted. Location: /var/log/boot.log*. Plaintext log file. This may be disabled in some distros; on newer systems, it is recommended to use the journal for boot-time data. The log may not have timestamps on each line; there is sometimes only a timestamp per file. Check the log for services that were started, to identify signs of attacker persistence or malicious activity", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "System Logs - Boot History", "category": "dfir", "platform": "linux"}}
{"text": "Global System Log: This log is used to store various system messages, including information about system startup and shutdown, system services and drivers, network events, and hardware devices. Location: Ubuntu: /var/log/syslog, RHEL: /var/log/messages. Plaintext log file. Typically very large in size; use tools like grep to search for key strings. The log file is typically rotated regularly, and older log data may be archived or deleted. The size and rotation schedule of the logs can be configured by the system administrator, normally with logrotate. Can contain similar information to /var/log/boot.log; check both files", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "System Logs - Global System Log", "category": "dfir", "platform": "linux"}}
{"text": "Running Services daemon.log: When available, the daemon.log (controlled by the syslog facility) provides a record of events and messages generated by system daemons. The log typically contains messages the status of services, configuration changes, and error messages. This can provide valuable information for troubleshooting and debugging purposes. Location: /var/log/daemon.log. Plaintext log file. Typically not recorded by default; a lot of this data is now written to the Journal or Syslog. To check if this log is enabled, look for the following line in rsyslog.conf: daemon.* /var/log/daemon.log. Some systems may use different names or locations, depending on the logging system in use", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "System Logs - Running Services daemon.log", "category": "dfir", "platform": "linux"}}
{"text": "The Journal: The journal provides an audit trail of activity on the system by logging various types of events, including system startup and shutdown, kernel messages, and system service and application events. It stores metadata, such as the hostname, system architecture, and boot ID, allowing responders to correlate activity across systems and time. Location: /var/log/journal/[UUID]/*.log. Logs are stored in a binary format", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "System Logs - The Journal", "category": "dfir", "platform": "linux"}}
{"text": "journalctl command options for DFIR: -S or --since= Show entries on or newer than the date specified (yyyy-mm-dd hh:mm:ss). -U or --until= Show entries on or older than the date specified. -b or --boot= Show messages from a specific boot session. -u Show messages for the specified systemd unit. -t Show messages for the specified syslog identifier. _COMM= Match the script name. _EXE= Match the executable name. -g Pattern match (grep) for the specified regular expression. -k or --dmesg Show only kernel messages", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "System Logs - journalctl Options", "category": "dfir", "platform": "linux"}}
{"text": "journalctl offline analysis: Analyzing a single file: journalctl --file [journal file]. Analyzing a folder of journal records: journalctl --directory [journal dir]. Analyzing a mounted filesystem: journalctl --root /mnt/evidence1. Analyzing a raw disk image: journalctl --image /dev/loop22. The journal subfolder name will correspond to the unique machine identifier for the relevant device. Confirm the correct machine identifier by reading the text file at /etc/machine-id", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "System Logs - journalctl Offline Analysis", "category": "dfir", "platform": "linux"}}
{"text": "User Logins: User login data is recorded in three binary log files. Data captured includes username, login terminal, and login/logoff times. Location: Users/sessions currently logged in: /var/run/utmp. Historical utmp data: /var/log/wtmp. Failed login events: /var/log/btmp", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Authentication Logs - User Logins Location", "category": "dfir", "platform": "linux"}}
{"text": "User Logins interpretation: utmp is only available on a live system and may not be available depending on how you have captured the data. Not all systems will record a btmp file. All three files are binary database files and need to be read with commands such as: last -F -f [evidence utmp/wtmp/btmp file], lastb -F -f [evidence btmp file], utmpdump [evidence wtmp file]. Note that lastlog and faillog are unreliable", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Authentication Logs - User Logins Interpretation", "category": "dfir", "platform": "linux"}}
{"text": "Authorization Session Logs: Account creation, user logins from external services and privilege use such as using sudo are recorded in an authorization log. The log location differs depending on the distro. Location: Ubuntu: /var/log/auth.log, RHEL: /var/log/secure. Plaintext log file", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Authentication Logs - Authorization Session Logs", "category": "dfir", "platform": "linux"}}
{"text": "Web Server Logs: Web servers are the backbone of the Internet and are essential for serving and delivering web content to users. This is one of the most common uses for Linux platforms globally. Two of the most popular applications are Nginx and Apache, and both store access logs that record information about requests made to the server. The error log records information about errors and problems that occur on the server. Location: Nginx: /var/log/nginx/. Apache HTTP Server: /var/log/apache2/. RHEL/CentOS: /var/log/httpd/", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - Web Server Logs Location", "category": "dfir", "platform": "linux"}}
{"text": "Web Server Logs interpretation: Access logs can include the client's IP address, the date and time of the request, the request method, the requested resource, the HTTP status code, and the size of the response. Both the Nginx and Apache default access log format is the Combined Log Format. Older Apache servers have the default access log format of the Common Log Format. Almost all commercial or enterprise web servers will use either the Common Log Format or the Combined Log Format for access logs. By default, the error log is stored in the same folder as the access log", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - Web Server Logs Interpretation", "category": "dfir", "platform": "linux"}}
{"text": "SSL/TLS Logs: Information about incoming Secure Sockets Layer (SSL) encrypted traffic or traffic using Transport Layer Security (TLS) to a web server, is logged in three different log files. Location: /var/log/[Application]/ssl_access_log, /var/log/[Application]/ssl_request_log, /var/log/[Application]/ssl_error_log", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - SSL/TLS Logs Location", "category": "dfir", "platform": "linux"}}
{"text": "ssl_access_log is used to track connections and for administrators to monitor the performance and security of the server and troubleshoot issues. This log can include: Date and time of the connection, IP address of the client making the connection, Certificate information presented by the client, Results of the SSL handshake process, Encryption algorithm and key size used for the connection, SSL protocol version used", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - ssl_access_log", "category": "dfir", "platform": "linux"}}
{"text": "ssl_request_log provides a more detailed record of SSL-encrypted connections. This log can include: SSL requests made by the client, Contents of the SSL request, Results of processing the request", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - ssl_request_log", "category": "dfir", "platform": "linux"}}
{"text": "ssl_error_log tracks errors related to SSL encryption. It records information about any issues that occur during the SSL handshake process or that prevent the establishment of a secure SSL connection", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - ssl_error_log", "category": "dfir", "platform": "linux"}}
{"text": "MySQL Logs: MySQL is a widely used open-source relational database management system. It also includes a comprehensive logging system, which by default involves writing to various log files, including the error log, the slow query log, and the general query log. MySQL allows configuration of the level of detail recorded in logs, although the default is basic logging and it may write to unexpected locations. Typically, logging and log locations are defined by the configuration file at: /etc/mysql/my.cnf or a subfolder of this folder. Check the configuration file to locate logs and determine current configuration. Log files are plaintext, so easily readable with a text editor or using the cat command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - MySQL", "category": "dfir", "platform": "linux"}}
{"text": "PostgreSQL Logs: PostgreSQL is an open-source relational database management system that provides advanced features like transaction management, user authentication, and data integrity. PostgreSQL has a comprehensive logging system and can be configured to ship logs to the standard system log, as well as configure the level of detail that is recorded. However, the default logging options are often insufficient for security purposes and require deliberate effort to turn on. Typically, logging and log locations are defined by the configuration file at: /var/lib/pgsql/data/postgresql.conf. Check the configuration file to locate logs and determine current configuration. Log files are plaintext, so easily readable with a text editor or using the cat command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - PostgreSQL", "category": "dfir", "platform": "linux"}}
{"text": "vsftpd Logs: vsftpd is one of the more commonly found enterprise FTP clients on Linux systems, which unlike most other FTP packages, provides a secure method for transferring files over a network. It is configurable and provides robust logging capabilities. Typically, logging is defined by the configuration file at: /etc/vsftpd.conf or /etc/vsftpd/vsftpd.conf. Log location: /var/log/vsftpd.log. The location of the configuration file on a live system can be established with the systemctl status vsftpd command. By default, vsftpd logs events to the syslog facility. By default only events of notice level or higher are logged", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - vsftpd", "category": "dfir", "platform": "linux"}}
{"text": "Samba (SMB) Logs: Samba uses the SMB protocol to allow Linux/Unix servers to share files, printers, and other resources with Windows-based clients. Samba logs important events in its operation, including user authentication attempts and server status changes. Typically, logging is defined by the configuration file at: /etc/samba/smb.conf. Log location: /var/log/samba/log.[hostname|IPaddress]. Samba can act as a client or a server. The default logging configuration is basic and largely set to support troubleshooting. Log files are plaintext, so easily readable with a text editor or using the cat command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Application Logs - Samba SMB", "category": "dfir", "platform": "linux"}}
{"text": "iptables Firewall Logs: The most basic host firewall in Linux is iptables. It provides a way to control incoming and outgoing network traffic based on a set of rules. If the LOG option is used, information on packets matching the rule will be logged to the kernel message log. Location: System Logs Kernel Messages (dmesg). On a live system, iptables logs in the kernel message log can be viewed using: dmesg or journalctl -t iptables", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Firewall Logs - iptables", "category": "dfir", "platform": "linux"}}
{"text": "Uncomplicated Firewall (UFW) Logs: UFW is a user-friendly front-end for iptables and a default firewall application in many Linux distributions, including Ubuntu. UFW is a default deny firewall, meaning it blocks all incoming traffic by default. Rules are then added to allow specific types of traffic. Location: /var/log/ufw.log. Logging is not turned on by default and must be enabled by the root account using ufw logging on. Log data generated by UFW (and iptables) can be noisy. Log files are plaintext, so easily readable with a text editor or using the cat command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Firewall Logs - UFW", "category": "dfir", "platform": "linux"}}
{"text": "firewalld Logs: firewalld is a common firewall management tool that is the default on RHEL/CentOS7 or later versions. It controls network traffic based on the rules specified in the firewall configuration, which can be changed dynamically without interrupting the network connections. The firewall also logs any events that occur if the log option is used. Location: /var/log/firewalld. firewalld does not log dropped packets by default; the log option is required. The default configuration is minimal logging. Logs can be very verbose, and therefore difficult to read. In mixed-mode, firewalld writes info-level log messages to syslog. Debug messages are written to the firewalld log file by default, but this can be configured. Info messages also go to stdout and stderr", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Firewall Logs - firewalld", "category": "dfir", "platform": "linux"}}
{"text": "auditd: auditd is a Linux utility for auditing system events, including user activity, system calls, and other events that can have a security impact. It operates at the kernel level, collecting data from the system and storing it in a binary format. Typically, logging and the log location is defined by the configuration file at: /etc/audit/auditd.conf. Log location: /var/log/audit/audit.log. auditd is not installed by default on Debian-family distros. Even where auditd is installed, the default settings are insufficient to provide much assistance to an investigation. Logs generated by auditd can be very verbose. Generate human-readable summaries of audit activity using the aureport tool. Search audit logs using the ausearch tool. Both aureport and ausearch query the live log on the running system by default. However, this can be overridden by specifying an input file with the -if argument", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Audit Logs - auditd", "category": "dfir", "platform": "linux"}}
{"text": "User-mode Rootkits: Operate in user space, where regular applications run. Typically hook application and system binaries to intercept and alter system calls", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkits - User-mode", "category": "dfir", "platform": "linux"}}
{"text": "Kernel-mode Rootkits: Most popular rootkits. More powerful and stealthy than user-mode rootkits. Operate within kernel space, giving direct access to hardware and kernel subsystems. They often modify kernel data structures or load as malicious kernel modules. Techniques include hiding their presence by tampering with kernel data structures such as linked lists and process tables. The most commonly found attack is the abuse of Loadable Kernel Modules (LKMs). Review Loadable Kernel Modules in the live kernel with the lsmod command. This command draws its information from the /proc/modules container", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkits - Kernel-mode", "category": "dfir", "platform": "linux"}}
{"text": "Bootloader Rootkits: Infect the bootloader, such as GRUB (GNU GRand Unified Bootloader), which allows launch on boot. They can initiate before the Linux kernel loads, making detection very difficult and allowing them to manipulate the boot process", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkits - Bootloader", "category": "dfir", "platform": "linux"}}
{"text": "Hardware/Firmware Rootkits: Target the firmware on devices. These rootkits can persist through operating system reinstallations and have control from the earliest stages of the boot process. Particularly challenging to detect and remove because they operate below the operating system level", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkits - Hardware/Firmware", "category": "dfir", "platform": "linux"}}
{"text": "Memory Rootkits: Reside solely in the system's RAM. Typically inject code into the running kernel and manipulate its execution while the system is running. Harder to detect but will not persist after a reboot unless reinjected", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkits - Memory", "category": "dfir", "platform": "linux"}}
{"text": "Library Rootkits: Target system libraries, replacing them or modifying their functions. Can intercept and modify inputs and outputs of library functions, altering the behavior of applications using the libraries without altering the applications directly", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkits - Library", "category": "dfir", "platform": "linux"}}
{"text": "Check for signs of known Linux rootkits on a live system: /usr/sbin/chkrootkit [options] [test], rkhunter [options]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkit Detection - chkrootkit and rkhunter", "category": "dfir", "platform": "linux"}}
{"text": "Review Loadable Kernel Modules for rootkits: Does the file name look legitimate? Malicious LKMs are often single-character names or contain typos from legitimate modules. Check the kernel log file (for example, dmesg) for anything unusual like tainting. Where possible, compare known-good lists of loaded modules to the evidence", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkit Detection - Review LKMs", "category": "dfir", "platform": "linux"}}
{"text": "Review running processes for library attacks: Check and validate the paths to the files are legitimate in the environment variables for the running process, this information is stored in /proc/$pid/environ. Use ldd to review an executable on disk and identify which shared libraries it calls compared to the libraries in the running process, this information is stored in /proc/[PID]/maps", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkit Detection - Library Attacks", "category": "dfir", "platform": "linux"}}
{"text": "Review system calls for rootkits: Review the global system call table for anything unusual. Use strace -p <PID> to connect a debugger to Process ID <PID> and validate what system calls each process is making. Use strace <command> to run a new command to check its system calls. Check the audit logs, if configured. Scan the environment with Yara rules, to look for known indicators", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Rootkit Detection - System Calls", "category": "dfir", "platform": "linux"}}
{"text": "Account Modification Signs of Attack: Brute-force attacks, Creating new accounts, Adding accounts to groups to elevate permissions, Adding SSH keys to the authorized_keys file, Giving themselves sudo rights", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Account Modification Signs", "category": "dfir", "platform": "linux"}}
{"text": "Account Modification Locations: Authentication logs (auth.log, secure, utmp, wtmp, btmp, etc.): Check for large numbers of failed logins", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Account Auth Logs", "category": "dfir", "platform": "linux"}}
{"text": "/etc/passwd: Check the user accounts, look for file last modification times, and check for users who have login shells first. Readable by all users. File structure: [Username]:[Password info (x = stored in shadow)]:[User ID (UID)]:[Group ID (GID)]:[User information (comments)]:[Home folder]:[Login shell]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - /etc/passwd", "category": "dfir", "platform": "linux"}}
{"text": "/etc/shadow: Same as the passwd file, look for any unexpected accounts and check the time the file was last modified. Check for unusual entries in the password field. Only readable by root user. File structure: [Username]:[Password info]:[Last password change]:[Minimum password age]:[Maximum password age]:[Password warning period]:[Password inactivity period]:[Account expiration date]:[Reserved field]. The [Password info] field has the structure: $[Hash algorithm code]$[Salt]$[Hash]. If the [Password info] field contains an asterisk (*) or exclamation marks, the account is locked and cannot be used for password-based login. The last three fields are rarely used", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - /etc/shadow", "category": "dfir", "platform": "linux"}}
{"text": "/etc/group: Check what groups exist and which accounts are in privileged groups (start with wheel, sudo, and adm). Check the last modification time", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - /etc/group", "category": "dfir", "platform": "linux"}}
{"text": "/etc/sudoers: Validate the last modification time. Check for users with excessive accounts, especially users who have ANY:ANY set with or without a password. The sudoers file is often overwritten by the system as part of updates/patches", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - /etc/sudoers", "category": "dfir", "platform": "linux"}}
{"text": "/etc/sudoers.d/*: As for the sudoers file, attackers prefer this location because it survives patching/system updates", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - /etc/sudoers.d", "category": "dfir", "platform": "linux"}}
{"text": "/home/[username]/.ssh/ and /root/.ssh/: The known_hosts file stores a record of public keys for systems the user account has connected to. The authorized_keys file contains public keys that are allowed to authenticate on this system", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - SSH Directories", "category": "dfir", "platform": "linux"}}
{"text": "Shell and Text Editor History Signs of Attack: Use of sudo/su, Cleartext passwords, Unusual command lines", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Shell History Signs", "category": "dfir", "platform": "linux"}}
{"text": ".bash_history or .zsh_history (shell history): Look for any unusual commands that have been run. The location of this file is stored in the $HISTFILE variable. Only written to disk on shell exit (if exit recognized by the OS). Order of commands is not reliable. Trivial for an attacker to edit or remove. May be truncated based on the current HISTFILESIZE setting, with oldest entries removed first", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Shell History Files", "category": "dfir", "platform": "linux"}}
{"text": "Text Editor History Files: .lesshst - Look for unusual searches that were conducted. .viminfo - Look for any unusual use of vi/vim. .mysql_history - Look for any unusual mysql activity. Any other history files such as .python_history, .gdb_history, or .local/share/nano/search_history", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Text Editor History", "category": "dfir", "platform": "linux"}}
{"text": "Common Persistence Methods Signs of Attack: New user accounts, SSH access, New cron jobs, New startup scripts, Modified binaries, Hidden files", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Persistence Signs", "category": "dfir", "platform": "linux"}}
{"text": "Persistence Locations - Cron: crontab; /etc/cron.d; /etc/cron.hourly; /etc/cron.daily; /etc/cron.weekly; /etc/cron.monthly; and /var/spool/crontabs folders: Look for a last modification time within the incident window and unusual or unexpected entries", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Persistence Cron", "category": "dfir", "platform": "linux"}}
{"text": "Persistence Locations - Startup Scripts: Known locations for startup scripts for that distro (mostly in the /etc/ folders). Check for new startup scripts in: ~/.bashrc, ~/.bash_aliases, ~/.profile (user specific profile, exact filename can vary), ~/.bash_profile (user specific profile, exact filename can vary), ~/.bash_login (user specific profile, exact filename can vary), ~/.bash_logout, /etc/profile (system-wide, global initialization file for login shells and called each time a user logs in), /etc/rc.local (system-wide boot script that is called as the system starts up)", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Persistence Startup Scripts", "category": "dfir", "platform": "linux"}}
{"text": "Persistence Additional Checks: Check for binaries modified during the incident window. Check for any hidden files (preceded with .)", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Persistence Additional", "category": "dfir", "platform": "linux"}}
{"text": "Networking Signs of Attack: Unusual ports being used, Long-lasting connections, Unexpected processes using the network", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Networking Signs", "category": "dfir", "platform": "linux"}}
{"text": "Networking Locations: /etc/hosts - Check that hostnames point to legitimate targets and haven't been modified by an attacker. /etc/resolv.conf and /etc/system/resolved.conf - Check that the nameserver settings are valid", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Networking Locations", "category": "dfir", "platform": "linux"}}
{"text": "Altered Files Signs of Attack: Adding users, Deleting history/anti-forensics, Hiding files, Staging data, Leaving backdoors", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Altered Files Signs", "category": "dfir", "platform": "linux"}}
{"text": "Altered Files Locations: Look for large files, especially archives. This can often be a sign that attackers are staging data for exfiltration. /dev - Look for regular files in here; it should only hold devices or links. Search for files with a modification time stamp that fits within the incident window. Remember that timestamps can be manipulated", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Altered Files Locations", "category": "dfir", "platform": "linux"}}
{"text": "Log Files Signs of Attack: Failed attempts to use sudo, Root account changing key system settings, New accounts/cron jobs being created, Unusual log entries during the incident window (in general the most effective way to work through logs is to follow the line of attack, log files are typically very noisy), Maliciously modified log entries, Deleted log entries or entire log files, Attack to logging service causing log corruption", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Log Files Signs", "category": "dfir", "platform": "linux"}}
{"text": "Log Files Locations: /var/log/, /var/run/ (symlink). Log management tool (logrotate) configuration: Configuration file /etc/logrotate.conf, Individual configurations /etc/logrotate.d/*, Scheduled task /etc/cron.daily/logrotate, Systemd timer /usr/lib/systemd/system/logrotate.*, State file (last rotation time): Ubuntu /var/lib/logrotate/status, RHEL /var/lib/logrotate.status", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Hunting Artifacts - Log Files Locations", "category": "dfir", "platform": "linux"}}
{"text": "Raw (often referred to as DD) image files: Often with an extension .dd, .raw, .001, .img. Easiest to mount; only requires the built-in mount command", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Image Types - Raw DD", "category": "dfir", "platform": "linux"}}
{"text": "E01 image files: EnCase Expert Witness Format (EWF). Industry standard in forensic evidence image formats. Files normally have an .E01 extension, but this can vary if the file is split. Files need to be converted to raw format first, this can be achieved using ewfmount, which is not installed by default", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Image Types - E01", "category": "dfir", "platform": "linux"}}
{"text": "VMDK image files: Virtual machine disk file. Can be mounted with vdfuse or guestmount, but neither is installed by default", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Image Types - VMDK", "category": "dfir", "platform": "linux"}}
{"text": "VHDX image files: Less commonly seen in Linux incidents. Can be mounted using guestmount, which is not installed by default", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Image Types - VHDX", "category": "dfir", "platform": "linux"}}
{"text": "Mounting a raw image file with one partition: mkdir [dir to use as mount point], mount -o ro [raw image file] [mount point dir]. The -o ro option mounts the image in read-only mode", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - Raw Single Partition", "category": "dfir", "platform": "linux"}}
{"text": "Mounting a raw image file with multiple partitions: fdisk -l [raw image file] OR mmls [raw image file]. Identify the partition you want to mount and multiply the partition start location by the sector size to get the offset. mount -o ro,offset=[offset] [raw image file] [mount point dir]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - Raw Multiple Partitions", "category": "dfir", "platform": "linux"}}
{"text": "Unmounting a raw image file: umount [mount point], rmdir [mount point dir]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - Unmount Raw", "category": "dfir", "platform": "linux"}}
{"text": "Mounting an LVM/LVM2 partition: fdisk -l [raw image file] OR mmls [raw image file]. Identify the partition you want to mount and multiply the partition start location by the sector size to get the offset. losetup -rf -o [offset] [raw image file]. losetup -a | grep [raw image file] - Identify the loopback device address. pvdisplay [loopback address] - Identify the Volume Group Name (VG Name). vgchange -a y [VG Name] - You can generally ignore warnings about old PV headers. lvscan | grep [VG Name] - Validate the Volume Group is ACTIVE and identify root device to mount. mkdir [dir to use as mount point]. mount -o ro, norecovery, noexec [device to mount] [mount point dir]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - LVM/LVM2 Partition", "category": "dfir", "platform": "linux"}}
{"text": "Unmounting an LVM/LVM2 partition: umount [mount point], vgchange -a n [VG Name], losetup -d [loopback address], rmdir [mount point dir]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - Unmount LVM/LVM2", "category": "dfir", "platform": "linux"}}
{"text": "Mounting an EWF image file with one partition: mkdir [dir to use as mount point for ewfmount command], ewfmount [E01 image file] [mount point for raw image], mkdir [dir to use as mount point for mount command], mount -o ro,norecovery [raw image file] [mount point]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - EWF Single Partition", "category": "dfir", "platform": "linux"}}
{"text": "Mounting an EWF image file with multiple partitions: mkdir [dir to use as mount point for ewfmount command], ewfmount [E01 image file] [mount point for raw image], mkdir [dir to use as mount point for mount command], fdisk -l [raw image file] OR mmls [E01 image file]. Identify the partition you want to mount and multiply the partition start location by the sector size to get the offset. mount -o ro,norecovery,offset=[offset] [raw image file] [mount point]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - EWF Multiple Partitions", "category": "dfir", "platform": "linux"}}
{"text": "Unmounting an EWF image file: umount [raw mount point], umount [EWF mount point], rmdir [raw mount point dir], rmdir [EWF mount point dir]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - Unmount EWF", "category": "dfir", "platform": "linux"}}
{"text": "Mounting a VMDK file: mkdir [dir to use as mount point], guestmount -a [VMDK file] -i --ro -o allow_other [mount point]. -a Specifies the source image to be mounted. -i Uses inspector to attempt to detect the operating system and mount points automatically. --ro Mount the image as read-only. -o Options allow_other: Allow other accounts to see the mounted filesystem", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - VMDK", "category": "dfir", "platform": "linux"}}
{"text": "Mounting a VHDX file: mkdir [dir to use as mount point], guestmount -a [VHDX file] -m [mount point in VHDX] --ro -o allow_other [mount point]. -a Specifies the source image to be mounted. -i Uses inspector to attempt to detect the operating system and mount points automatically. -m Specifies the mount point within the VHDX file to mount. --ro Mount the image as read-only. -o Options allow_other: Allow other accounts to see the mounted filesystem", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - VHDX", "category": "dfir", "platform": "linux"}}
{"text": "Unmounting a VMDK or VHDX file: guestunmount [mountpoint]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - Unmount VMDK VHDX", "category": "dfir", "platform": "linux"}}
{"text": "Mounting with qemu-nbd: modprobe nbd, qemu-nbd -f [image file format] -c /dev/nbd0 [image file], mkdir [dir to use as mount point], mount /dev/nbd0p1 [mount point]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - qemu-nbd Mount", "category": "dfir", "platform": "linux"}}
{"text": "Unmounting with qemu-nbd: umount [mount point], qemu-nbd -d /dev/nbd0, rmdir [mount point dir]", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Mounting - qemu-nbd Unmount", "category": "dfir", "platform": "linux"}}
{"text": "Linux Folder Hierarchy: / filesystem root. /boot, /sbin, /bin - Binaries. /lib - Libraries. /etc - configuration files. /root - root user's home directory. /home - user home directories. /opt - optional third-party software packages. /var - Variable files (log files, temporary or persistent data for various services and applications). /cdrom, /media, /run - Runtime. /proc - Virtual FS, non-persistent. /tmp - temporary files. /usr - user-related data, including executables and libraries. /mnt - mounted filesystems. /dev - device files", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Folder Hierarchy Overview", "category": "dfir", "platform": "linux"}}
{"text": "Important DFIR locations: /bin and /sbin - binary executables. /etc - configuration files. /dev - device files. /home - user home directories. /lib* - libraries and system files. /mnt and /media - mounted filesystems. /opt - optional third-party software packages. /root - root user's home directory. /tmp - temporary files. /usr - user-related data, including executables and libraries. /var - log files, and temporary or persistent data for various services and applications", "metadata": {"source": "SANS_Linux_IR_Hunting", "title": "Linux Folder Hierarchy DFIR Locations", "category": "dfir", "platform": "linux"}}
