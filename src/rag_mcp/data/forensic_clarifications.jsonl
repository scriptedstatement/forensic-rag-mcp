{"text": "FORENSIC CLARIFICATION: Amcache.hve\n\nWHAT IT PROVES:\n- Evidence that an executable FILE WAS PRESENT on the system\n- File metadata: SHA1 hash (first 31MB only), size, publisher, version info\n- File path where the executable existed\n\nWHAT IT DOES NOT PROVE:\n- Execution. Amcache entries CAN be created without the program ever running.\n- Amcache is NOT a true execution log.\n\nTIMESTAMP FIELDS - WHAT THEY ACTUALLY MEAN:\n- Registry Key LastWrite (FileKeyLastWriteTimestamp): When the Amcache ENTRY was created/updated. Often when Microsoft Compatibility Appraiser SCANNED the file, NOT when executed. Some tools label this 'First executed timestamp' but this is MISLEADING.\n- LinkDate: PE header compilation timestamp - when the DEVELOPER BUILT the executable. Has nothing to do with execution or presence on THIS system.\n- LastScanTime: When Microsoft Compatibility Appraiser scheduled task ran.\n- InstallDate: When the OS first recorded/recognized the application.\n- LastModified: File modification time from filesystem metadata ($STANDARD_INFORMATION).\n\nNONE OF THESE ARE EXECUTION TIME.\n\nHOW AMCACHE IS POPULATED:\n- Microsoft Compatibility Appraiser scheduled task scans directories (Program Files, Desktop, Start Menu)\n- File copy/installation operations\n- Application compatibility shimming (this DOES indicate execution)\n- Only the shimming category reliably indicates execution; the others just confirm presence\n\nWHY THIS MATTERS:\n- SANS FOR500 states: 'Amcache should be used as an indication of executable and driver presence on the system, but not to prove actual execution.'\n- Stating Amcache 'proves execution' in a report is forensically inaccurate and can be challenged in legal proceedings.\n- The scheduled Compatibility Appraiser task can add entries for files that were NEVER executed.\n\nCORROBORATION FOR EXECUTION:\n- Prefetch files (.pf) - strong execution evidence\n- UserAssist (GUI execution)\n- BAM/DAM (Background/Desktop Activity Moderator)\n- Windows Event Logs (4688, Sysmon 1)\n- SRUM database\n- Memory forensics\n\nSource: SANS FOR500, SANS FOR508, Kaspersky Securelist Research, Cyber Triage 2025", "metadata": {"source": "forensic_clarifications", "category": "artifact_clarification", "artifact": "amcache", "title": "Amcache: Proves Presence, Not Execution - Timestamps Explained"}}
{"text": "FORENSIC CLARIFICATION: Shimcache / AppCompatCache\n\nWHAT IT PROVES:\n- A FILE WAS PRESENT on the system\n- The file path that was checked for compatibility\n- Last modification time of the file ($STANDARD_INFORMATION) - this is the FILE's modification time, NOT when it was executed or accessed\n- Order of entries (most recent prepended to the list)\n\nWHAT IT DOES NOT PROVE:\n- Time of execution or order of execution. Shimcache entries are created when the OS performs compatibility checks, which can happen during file operations OTHER than execution, such as viewing the executable file in File Explorer.\n- Timeframes. The only timestamp is the file's $SI modification time.\n\nTHE INSERT FLAG - NUANCED UNDERSTANDING:\n- The INSERT flag does suggest whether or not the executable ran. It is MORE RELIABLE for non-Windows executables (software not installed by default with Windows).\n- The INSERT flag is LESS RELIABLE for built-in Windows binaries.\n- Research has observed many cases where a Windows executable in a KNOWN execution state is NOT correctly reported by the INSERT flag.\n- For third-party/non-Windows executables: INSERT flag set strongly suggests execution occurred.\n- For Windows built-in binaries: INSERT flag is unreliable and should not be used as an indicator.\n\nWHY THIS MATTERS:\n- Shimcache is populated by the Application Compatibility subsystem during file metadata lookups.\n- Simply opening a folder containing executables in the GUI, copying/moving files using the GUI, or running file system operations can create entries.\n- Forensic reports should be careful when stating Shimcache proves execution.\n\nCORROBORATION FOR EXECUTION:\n- Prefetch files (.pf) - strong execution evidence\n- BAM/DAM entries\n- Process execution logs (4688, Sysmon 1)\n- Memory forensics\n\nBEST PRACTICE:\n- Use Shimcache to establish file PRESENCE.\n- State 'the file was present on the system' - Shimcache proves this.\n- Do NOT use Shimcache for execution timeframes - it only contains file modification time, not presence or execution time.\n- For non-Windows executables, INSERT flag can support execution theory.\n- For Windows built-in binaries, seek additional corroboration of execution and do not rely on the INSERT flag.\n\nSource: SANS FOR500, SANS FOR508, Mandiant Research", "metadata": {"source": "forensic_clarifications", "category": "artifact_clarification", "artifact": "shimcache", "title": "Shimcache: Proves Presence, INSERT Flag Nuanced"}}
{"text": "FORENSIC CLARIFICATION: Pass-the-Hash (PTH) Detection\n\nCRITICAL DISTINCTION:\n- NTLM authentication in Windows Event Logs DOES NOT EQUAL Pass-the-Hash.\n- NTLM is a legitimate authentication protocol used constantly in normal Windows environments.\n- Pass-the-Hash is a specific ATTACK TECHNIQUE where a stolen NTLM hash is used without knowing the plaintext password.\n\nWHAT LOGS SHOW:\n- Event 4624 (Logon) with Logon Type 3 (Network) and NTLM authentication shows a network logon using NTLM.\n- This is NORMAL BEHAVIOR in most Windows environments.\n- You CANNOT determine from the event alone whether the authenticating party knew the password or used a stolen hash.\n- PTH looks IDENTICAL to legitimate NTLM auth and stolen password usage in the logs.\n\nTHE CORE PROBLEM:\n- If an attacker has the plaintext password, they can do everything PTH does.\n- PTH is only the specific answer when evidence shows the attacker had the HASH but NOT the plaintext password.\n- From logs alone, you cannot distinguish PTH from stolen password usage.\n\nWHAT MIGHT SUGGEST PTH (not prove):\n- Evidence of HASH theft (not password theft):\n  - LSASS memory access (dumps hashes; plaintext only if WDigest enabled)\n  - SAM/SECURITY hive extraction (contains hashes)\n  - NTDS.dit extraction (contains domain hashes)\n  - Combined with NO evidence of password theft (no phishing, keylogger, credential prompt)\n- If you can show the attacker obtained hashes but NOT plaintext, PTH becomes more likely than stolen password.\n\nWHAT DOES NOT INDICATE PTH SPECIFICALLY:\n- NTLM auth from unexpected source - could be PTH, stolen password, or delegation abuse\n- Lateral movement patterns - could be any credential abuse technique\n- Sequential logons across systems - could be legitimate admin work or any attack technique\n- NTLM when Kerberos available - NTLM fallback is common and usually benign\n\nFORENSIC BEST PRACTICE:\n- NEVER state 'Pass-the-Hash detected' based solely on NTLM logon events.\n- State 'NTLM authentication observed' and note whether it is anomalous for that environment.\n- Investigate the SOURCE of authentication - was the user actually at that system?\n- Look for credential theft artifacts on source systems - specifically hash theft vs password theft.\n- Correlate with other lateral movement indicators.\n- Describe as 'activity CONSISTENT WITH credential abuse, possibly Pass-the-Hash' when hash theft evidence exists.\n\nRELATED TECHNIQUES TO DISTINGUISH:\n- Pass-the-Hash (T1550.002): Stolen NTLM hash used for NTLM auth\n- Pass-the-Ticket (T1550.003): Stolen Kerberos ticket\n- Overpass-the-Hash (T1550.002): NTLM hash used to obtain Kerberos ticket\n- Stolen password: Attacker knows plaintext, can use NTLM or Kerberos\n- Normal NTLM auth: Legitimate authentication (vast majority of cases)\n\nSource: SANS FOR508, MITRE ATT&CK T1550.002, Microsoft Security Documentation", "metadata": {"source": "forensic_clarifications", "category": "technique_clarification", "artifact": "pass-the-hash", "title": "Pass-the-Hash: NTLM Authentication Does Not Equal PTH"}}
{"text": "FORENSIC CLARIFICATION: Prefetch Files\n\nWHAT IT PROVES:\n- Strong evidence of execution (one of the most reliable execution artifacts)\n- Up to 8 specific execution timestamps per prefetch file\n- Run count for executions tracked by THAT prefetch file\n- Files and directories accessed during execution\n\nWHAT EXAMINERS OFTEN OVERSTATE:\n\nMULTIPLE PREFETCH FILES PER EXECUTABLE:\n- The same executable run from different paths or with different command-line switches can create separate .pf files.\n- Each prefetch file has its own run count and timestamps.\n- Do not assume a single prefetch file represents all executions of a program.\n\nRUN COUNT SCOPE:\n- The run count reflects executions tracked by THIS prefetch file only.\n- It is not a total lifetime execution count for the program.\n\nMISSING PREFETCH DOES NOT MEAN NO EXECUTION:\n- Prefetch files can be deleted by attackers or users.\n- Prefetch files age out when the 1024 file limit is reached.\n\nABSENCE OF EVIDENCE:\n- A prefetch file showing execution beginning on a specific date does NOT rule out previous executions at earlier dates that were recorded in a now deleted prefetch file or in a prefetch file recorded for execution from another path, filename, or (in some cases) command line switches.\n- Prior prefetch data may have been deleted or aged out.\n\nBEST PRACTICE:\n- Qualify statements: say 'the prefetch file shows...' rather than making absolute claims about execution history.\n- Prefetch proves execution occurred; but recognize that execution could have occurred for which prefetch records no longer exist.\n- Consider prefetch alongside other execution artifacts.\n\nSource: SANS FOR508", "metadata": {"source": "forensic_clarifications", "category": "artifact_clarification", "artifact": "prefetch", "title": "Prefetch: Strong Execution Evidence With Limitations"}}
{"text": "FORENSIC CLARIFICATION: Registry LastWrite Timestamps\n\nWHAT IT PROVES:\n- The timestamp when a registry KEY was last modified\n\nWHAT IT DOES NOT PROVE:\n- WHICH value within the key was changed\n- The timestamp of individual value changes\n- Whether a specific value was the cause of the LastWrite update\n\nTHE CORE LIMITATION:\n- Registry timestamps exist at the KEY level only, not at the VALUE level.\n- A key containing 50 values has ONE timestamp shared across all of them.\n- When any value is changed, the key's LastWrite updates, but you cannot determine which value triggered it.\n\nCOMMON EXAMINER ERROR:\n- Stating 'this registry value was modified at [timestamp]' is forensically inaccurate.\n- You can only state 'this registry key was modified at [timestamp]' and note which values exist within it.\n\nBEST PRACTICE:\n- State 'the registry key containing this value was last modified at [timestamp].'\n- Do not attribute timestamps to specific values.\n- Consider that other values in the same key may have caused the LastWrite update.\n\nSource: Microsoft", "metadata": {"source": "forensic_clarifications", "category": "artifact_clarification", "artifact": "registry", "title": "Registry LastWrite: Key Timestamps, Not Value Timestamps"}}
